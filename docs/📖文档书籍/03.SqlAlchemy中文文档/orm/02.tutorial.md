---
title: 对象关系教程
date: 2021-02-20 23:28:47
permalink: /sqlalchemy/orm/tutorial/
categories:
  - 📖好书
  - SqlAlchemy 中文文档
  - orm
tags:
---
对象关系教程[¶](#object-relational-tutorial "Permalink to this headline")
=========================================================================

SQLAlchemy
ORM 提供了将用户定义的 Python 类和数据库表以及这些类（对象）的实例与其对应表中的行相关联的方法。它包括一个透明地同步对象及其相关行之间状态的所有更改的系统，称为[工作单元](glossary.html#term-unit-of-work)，以及用于根据用户定义的类及其定义的表达式表达数据库查询的系统彼此之间的关系。

ORM 与构建 ORM 的 SQLAlchemy 表达式语言形成鲜明对比。鉴于在[SQL表达式语言教程](core_tutorial.html)中引入的 SQL 表达式语言提供了直接表示关系数据库的原始结构的系统，而没有意见，ORM 呈现高级别和抽象的使用模式，是表达式语言的应用使用的示例。

虽然 ORM 和表达式语言的使用模式之间存在重叠，但它们的相似之处却比最初出现时更为肤浅。从用户定义的[域模型](glossary.html#term-domain-model)的角度来看，数据的结构和内容是透明持久化的，并从其底层存储模型刷新。另一种方法从文字模式和 SQL 表达式表达式的角度来看，它们被显式地组合成数据库单独消费的消息。

可以仅使用对象关系映射器来构建成功的应用。在高级情况下，使用 ORM 构建的应用程序可能会在需要特定数据库交互的某些区域中直接偶尔使用表达式语言。

The following tutorial is in doctest format, meaning each `>>>` line represents something you can type at a Python command prompt, and the following text represents the expected return value.

版本检查[¶](#version-check "Permalink to this headline")
--------------------------------------------------------

快速检查以确认我们至少处于 SQLAlchemy 的**版本 1.1**：

    >>> import sqlalchemyplain
    >>> sqlalchemy.__version__ 
    1.1.0

连接[¶ T0\>](#connecting "Permalink to this headline")
------------------------------------------------------

对于本教程，我们将使用一个仅内存的 SQLite 数据库。要连接，请使用[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")：

    >>> from sqlalchemy import create_engineplainplain
    >>> engine = create_engine('sqlite:///:memory:', echo=True)

`echo`标志是设置 SQLAlchemy 日志记录的快捷方式，它是通过 Python 的标准`日志`模块完成的。启用它，我们将看到生成的所有 SQL。如果您正在学习本教程并希望产生更少的输出，请将其设置为`False`。本教程将把 SQL 格式化为一个弹出窗口，所以它不会妨碍我们；只需点击“SQL”链接即可查看正在生成的内容。

[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")的返回值是[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")的一个实例，它表示数据库的核心接口，通过处理方言数据库和[DBAPI](glossary.html#term-dbapi)的使用细节。在这种情况下，SQLite 方言将向 Python 内置的`sqlite3`模块解释指令。

懒惰连接

由[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")首次返回的[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")实际上并未尝试连接到数据库；只有在第一次被要求对数据库执行任务时，才连接到数据库。

第一次调用[`Engine.execute()`](core_connections.html#sqlalchemy.engine.Engine.execute "sqlalchemy.engine.Engine.execute")或[`Engine.connect()`](core_connections.html#sqlalchemy.engine.Engine.connect "sqlalchemy.engine.Engine.connect")的方法时，[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")才会建立一个真实的[DBAPI](glossary.html#term-dbapi)连接到数据库，然后用于发出 SQL。使用 ORM 时，我们通常不会直接使用[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")；相反，它在后台被 ORM 使用，我们将很快看到。

也可以看看

[数据库网址](core_engines.html#database-urls) -
包括连接到多种数据库的[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")示例，其中包含指向更多信息的链接。

声明映射[¶](#declare-a-mapping "Permalink to this headline")
------------------------------------------------------------

当使用 ORM 时，配置过程首先描述我们将要处理的数据库表，然后定义我们用来映射到那些表的类。在现代 SQLAlchemy 中，这两个任务通常使用称为[Declarative](extensions_declarative_index.html)方法一起执行，这允许我们创建包含指令的类来描述它们将被映射到的实际数据库表。

使用 Declarative 方法定义的映射类依据一个基类，这个基类是维系类和数据表关系的目录
- 我们说说的**Declarative base
class**。在一个普通的模块入口中，应用通常只需要有一个 base 的实例。我们使用[`declarative_base()`](extensions_declarative_api.html#sqlalchemy.ext.declarative.declarative_base "sqlalchemy.ext.declarative.declarative_base")函数创建基类，如下所示：

    >>> from sqlalchemy.ext.declarative import declarative_baseplainplain

    >>> Base = declarative_base()

现在我们有一个“base”，我们可以定义任何数量的映射类。我们将从一个名为`users`的表开始，它将为使用我们的应用程序的最终用户存储记录。一个名为`User`的新类将是我们映射此表的类。在类中，我们定义了我们要映射到的表的详细信息，主要是表名，列的名称和数据类型：

    >>> from sqlalchemy import Column, Integer, Stringplain
    >>> class User(Base):
    ...     __tablename__ = 'users'
    ...
    ...     id = Column(Integer, primary_key=True)
    ...     name = Column(String)
    ...     fullname = Column(String)
    ...     password = Column(String)
    ...
    ...     def __repr__(self):
    ...        return "<User(name='%s', fullname='%s', password='%s')>" % (
    ...                             self.name, self.fullname, self.password)

小费

`User`类定义了一个`__ repr __()`方法，但注意是**可选**；我们只在本教程中实现它，以便我们的示例显示格式很好的`用户`对象。

使用 Declarative 的类至少需要一个`__ tablename __`属性和至少一个[`Column`](core_metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")，它是主键[[1]](#id2)的一部分。SQLAlchemy 从不对类引用的表本身做任何假设，包括它没有内置的名称，数据类型或约束的约定。但这并不意味着需要样板；而是鼓励使用辅助函数和 mixin 类创建自己的自动约定，这在[Mixin 和 Custom
Base
Classes](extensions_declarative_mixins.html#declarative-mixins)中有详细描述。

构造类时，Declarative会使用称为[描述符](glossary.html#term-descriptors)的特殊 Python 访问器替换所有[`Column`](core_metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象；这是一个称为[instrumentation](glossary.html#term-instrumentation)的过程。“instrumented”映射类将为我们提供在 SQL 上下文中引用我们的表的方法，以及从数据库中持久化和加载列的值。

除了映射过程对我们的类做的外，类另外主要是一个普通的 Python 类，我们可以定义任何数量的普通属性和我们的应用程序所需的方法。

  ------------------ --------------------------------------------------------------------------------------------------------------
  [[1] T0\>](#id1)   有关为什么需要主键的信息，请参阅[如何映射没有主键的表？](faq_ormconfiguration.html#faq-mapper-primary-key)。
  ------------------ --------------------------------------------------------------------------------------------------------------

构造模式[¶](#create-a-schema "Permalink to this headline")
----------------------------------------------------------

使用通过声明式系统构建的`User`类，我们定义了有关表的信息，称为表元数据。SQLAlchemy 用于表示特定表的此信息的对象称为[`表`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，这里 Declarative 已经为我们做了一个。我们可以通过检查`__table__`属性来看到这个对象：

    >>> User.__table__plainplainplain
    Table('users', MetaData(bind=None),
                Column('id', Integer(), table=<users>, primary_key=True, nullable=False),
                Column('name', String(), table=<users>),
                Column('fullname', String(), table=<users>),
                Column('password', String(), table=<users>), schema=None)

类映射

尽管强烈建议声明性系统，但为了使用 SQLAlchemy 的 ORM 并不是必需的。在 Declarative 之外，任何普通的 Python 类都可以直接使用[`mapper()`](mapping_api.html#sqlalchemy.orm.mapper "sqlalchemy.orm.mapper")函数映射到任何[`表`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")；这个不太常见的用法在[Classical
Mappings](mapping_styles.html#classical-mapping)中描述。

当我们声明我们的类时，Declarative 使用 Python 元类来完成类声明完成后的额外活动；在这个阶段，然后根据我们的规范创建一个[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，并通过构造一个[`Mapper`](mapping_api.html#sqlalchemy.orm.mapper.Mapper "sqlalchemy.orm.mapper.Mapper")对象将其与类关联。这个对象是我们通常不需要直接处理的幕后对象（虽然它可以在我们需要时提供关于我们映射的大量信息）。

[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象是一个更大集合的成员，名为[`MetaData`](core_metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")。当使用 Declarative 时，这个对象可以使用我们的声明基类的`.metadata`属性。

The [`MetaData`](core_metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
is a registry which includes the ability to emit a limited set of schema
generation commands to the database.
由于我们的 SQLite 数据库实际上并不存在`users`表，我们可以使用[`MetaData`](core_metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")向所有尚未存在的表发出 CREATE
TABLE 语句到数据库。下面，我们调用[`MetaData.create_all()`](core_metadata.html#sqlalchemy.schema.MetaData.create_all "sqlalchemy.schema.MetaData.create_all")方法，传入我们的[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")作为数据库连接的来源。我们将看到首先发出特殊命令来检查`users`表的存在，然后是实际的`CREATE TABLE`声明：

    >>> Base.metadata.create_all(engine)plainplain
    SELECT ...
    PRAGMA table_info("users")
    ()
    CREATE TABLE users (
        id INTEGER NOT NULL, name VARCHAR,
        fullname VARCHAR,
        password VARCHAR,
        PRIMARY KEY (id)
    )
    ()
    COMMIT

最小表格描述与完整描述

熟悉 CREATE
TABLE 语法的用户可能注意到 VARCHAR 列的生成没有长度；在 SQLite 和 Postgresql 上，这是一个有效的数据类型，但是在其他情况下，它是不允许的。因此，如果在其中一个数据库上运行本教程，并且希望使用 SQLAlchemy 发出 CREATE
TABLE，则可以为[`String`](core_type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")类型提供“length”，如下所示：

    Column(String(50))plainplain

[`String`](core_type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")上的长度字段以及[`Integer`](core_type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")，[`Numeric`](core_type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")等可用的类似精度/缩放字段。除了创建表格时，不会被 SQLAlchemy 引用。

此外，Firebird 和 Oracle 需要序列来生成新的主键标识符，并且 SQLAlchemy 不会在未经指示的情况下生成或采用这些标识符。为此，您可以使用[`Sequence`](core_defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")结构：

    from sqlalchemy import Sequenceplainplain
    Column(Integer, Sequence('user_id_seq'), primary_key=True)

因此，通过我们的声明性映射生成的完整，万无一失的[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")是：

    class User(Base):plainplainplain
        __tablename__ = 'users'
        id = Column(Integer, Sequence('user_id_seq'), primary_key=True)
        name = Column(String(50))
        fullname = Column(String(50))
        password = Column(String(12))

        def __repr__(self):
            return "<User(name='%s', fullname='%s', password='%s')>" % (
                                    self.name, self.fullname, self.password)

我们单独包含这个更详细的表定义，以突出显示主要针对 Python 内使用的最小构造与将用于在具有更严格要求的特定后端组上发出 CREATE
TABLE 语句的构造之间的差异。

创建映射类的实例[¶](#create-an-instance-of-the-mapped-class "Permalink to this headline")
-----------------------------------------------------------------------------------------

完成映射后，我们现在创建并检查`User`对象：

    >>> ed_user = User(name='ed', fullname='Ed Jones', password='edspassword')plainplainplain
    >>> ed_user.name
    'ed'
    >>> ed_user.password
    'edspassword'
    >>> str(ed_user.id)
    'None'

`__ init __()`方法

我们使用 Declarative 系统定义的`User`类已经提供了一个构造函数（例如`__init__()`方法），它自动接受匹配我们列的关键字名称映射。我们可以自由定义我们喜欢的类的任何明确的`__init__()`方法，它将覆盖由 Declarative 提供的默认方法。

尽管我们没有在构造函数中指定它，但当我们访问它时，`id`属性仍会产生一个`None`值（与 Python 通常提升`AttributeError`为未定义的属性）。SQLAlchemy 的[instrumentation](glossary.html#term-instrumentation)通常在首次访问时为列映射属性生成此默认值。对于那些我们实际赋予值的属性，工具系统正在跟踪这些赋值，以便在最终的 INSERT 语句中使用，以便发送到数据库。

创建会话[¶](#creating-a-session "Permalink to this headline")
-------------------------------------------------------------

我们现在准备开始与数据库会话了。ORM 通过[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")与数据库建立连接的。当我们首次启动应用程序时，与我们的[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")语句相同，我们定义一个[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")类，作为新的[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")对象：

    >>> from sqlalchemy.orm import sessionmaker
    >>> Session = sessionmaker(bind=engine)

在您的应用程序在定义模块级对象时尚未具有[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")的情况下，只需按如下设置：

    >>> Session = sessionmaker()

稍后，当您使用[`create_engine()`](core_engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")创建引擎时，请使用[`configure()`](session_api.html#sqlalchemy.orm.session.sessionmaker.configure "sqlalchemy.orm.session.sessionmaker.configure")将其连接到[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")

    >>> Session.configure(bind=engine)  # once engine is availableplain

会话生命周期模式

何时制作[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")的问题很大程度上取决于正在构建的应用程序类型。请记住，[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")只是对象的工作空间，对于特定的数据库连接是本地的
-
如果您在应用程序线程中将宴会派对上的应用程序线程视为 guest，[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")关于此主题的更多信息可在[When
do I construct a Session, when do I commit it, and when do I close
it?](session_basics.html#session-faq-whentocreate)。

此定制的[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")类将创建绑定到我们的数据库的新[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")对象。调用[`sessionmaker`](session_api.html#sqlalchemy.orm.session.sessionmaker "sqlalchemy.orm.session.sessionmaker")时也可以定义其他事务特征；这些在后面的章节中描述。然后，每当需要与数据库进行对话时，只需要实例化一个[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")：

    >>> session = Session()

上述[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")与我们启用 SQLite 的[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")相关联，但尚未打开任何连接。当它第一次使用时，它从由[`Engine`](core_connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")维护的连接池中检索连接，并保持到它，直到我们提交所有更改和/或关闭会话对象。

添加和更新对象[¶](#adding-and-updating-objects "Permalink to this headline")
----------------------------------------------------------------------------

要保留我们的`User`对象，我们[`add()`](session_api.html#sqlalchemy.orm.session.Session.add "sqlalchemy.orm.session.Session.add")到我们的[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")

    >>> ed_user = User(name='ed', fullname='Ed Jones', password='edspassword')plainplainplainplain
    >>> session.add(ed_user)

此时，我们说这个实例**正在等待**；尚未发出 SQL，并且对象尚未由数据库中的行表示。只要需要，[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")将发布 SQL 来坚持`Ed  tt4> 琼斯` **冲洗 T6\>。**如果我们在数据库中查询`Ed Jones`，所有待处理的信息将首先被刷新，然后立即发出查询。

例如，下面我们创建一个新的[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")对象，它加载`User`的实例。我们“过滤”`ed`的`name`属性，并指示我们只想获取完整列表中的第一个结果。返回一个与我们添加的相同的`User`实例：

    sql>>> our_user = session.query(User).filter_by(name='ed').first() # doctest:+NORMALIZE_WHITESPACEplain
    BEGIN (implicit)
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('ed', 'Ed Jones', 'edspassword')
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ?
     LIMIT ? OFFSET ?
    ('ed', 1, 0)
    >>> our_user
    <User(name='ed', fullname='Ed Jones', password='edspassword')>

事实上，[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")已经识别出返回的行是与其内部对象映射中已经表示的**相同的**行，因此我们实际上得到了与我们刚才添加的相同的实例：

    >>> ed_user is our_userplain
    True

这里工作的 ORM 概念被称为[身份映射](glossary.html#term-identity-map)并且确保在[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")内的特定行上的所有操作对相同的数据集进行操作。一旦具有特定主键的对象出现在[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")中，那么[`会话`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")上的所有 SQL 查询将始终为该特定主键返回相同的 Python 对象；如果试图在会话中放置具有相同主键的第二个已经持久化的对象，它也将引发错误。

我们可以使用[`add_all()`](session_api.html#sqlalchemy.orm.session.Session.add_all "sqlalchemy.orm.session.Session.add_all")一次添加更多`User`对象：

    >>> session.add_all([plain
    ...     User(name='wendy', fullname='Wendy Williams', password='foobar'),
    ...     User(name='mary', fullname='Mary Contrary', password='xxg527'),
    ...     User(name='fred', fullname='Fred Flinstone', password='blah')])

此外，我们认为 Ed 的密码不是太安全，所以让我们改变它：

    >>> ed_user.password = 'f8s7ccs'plainplain

[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")正在关注。例如，它知道`Ed Jones`已被修改：

    >>> session.dirtyplain
    IdentitySet([<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>])

并且三个新的`User`对象正在等待：

    >>> session.new  # doctest: +SKIP
    IdentitySet([<User(name='wendy', fullname='Wendy Williams', password='foobar')>,
    <User(name='mary', fullname='Mary Contrary', password='xxg527')>,
    <User(name='fred', fullname='Fred Flinstone', password='blah')>])

我们告诉[`session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")，我们要发布对数据库的所有剩余更改，并提交已经在进行中的事务。我们通过[`commit()`](session_api.html#sqlalchemy.orm.session.Session.commit "sqlalchemy.orm.session.Session.commit")来实现。[`session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")发出用于“ed”上的密码更改的`UPDATE`语句，以及三个新的`User`语句`INSERT`我们添加的对象：

    sql>>> session.commit()plainplain
    UPDATE users SET password=? WHERE users.id = ?
    ('f8s7ccs', 1)
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('wendy', 'Wendy Williams', 'foobar')
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('mary', 'Mary Contrary', 'xxg527')
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('fred', 'Fred Flinstone', 'blah')
    COMMIT

[`commit()`](session_api.html#sqlalchemy.orm.session.Session.commit "sqlalchemy.orm.session.Session.commit")刷新数据库中剩余的任何更改，并提交事务。session 引用的连接资源现在返回到连接池。此会话的后续操作将发生在**新**事务中，这将在第一次需要时再次重新获取连接资源。

如果我们看一下 Ed 的`id`属性，它早先是`None`，它现在有一个值：

    sql>>> ed_user.id # doctest: +NORMALIZE_WHITESPACEplain
    BEGIN (implicit)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.id = ?
    (1,)
    1

在[`会话`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")在数据库中插入新行后，所有新生成的标识符和数据库生成的默认值立即或通过首次加载访问在实例上可用。在这种情况下，整个行在访问时重新加载，因为在我们发出[`commit()`](session_api.html#sqlalchemy.orm.session.Session.commit "sqlalchemy.orm.session.Session.commit")之后开始一个新事务。SQLAlchemy 默认情况下刷新第一次在新事务中访问之前的事务的数据，以便最近的状态可用。重新加载的级别是可以配置的，如[*使用 session*](session.html)中所述。

会话对象状态

由于我们的`用户`对象从[`会话`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")之外移动到没有主键的[`会话`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")内部，为了实际插入，它在三**暂停**，**等待**和**持久性**中的四个可用的“对象状态”。意识到这些状态，它们的含义总是一个好主意
-
请务必阅读[Quickie 简介到对象状态](session_state_management.html#session-object-states)以便快速了解。

回滚[¶](#rolling-back "Permalink to this headline")
---------------------------------------------------

由于[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")在一个事务中工作，因此我们可以回滚更改。让我们做将被还原的两个更改；
`ed_user`的用户名设置为`Edwardo`：

    >>> ed_user.name = 'Edwardo'

我们添加另一个错误的用户`fake_user`：

    >>> fake_user = User(name='fakeuser', fullname='Invalid', password='12345')plainplainplain
    >>> session.add(fake_user)

查询会话，我们可以看到它们被刷入当前事务：

    sql>>> session.query(User).filter(User.name.in_(['Edwardo', 'fakeuser'])).all()plain
    UPDATE users SET name=? WHERE users.id = ?
    ('Edwardo', 1)
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('fakeuser', 'Invalid', '12345')
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name IN (?, ?)
    ('Edwardo', 'fakeuser')
    [<User(name='Edwardo', fullname='Ed Jones', password='f8s7ccs')>, <User(name='fakeuser', fullname='Invalid', password='12345')>]

回滚，我们可以看到`ed_user`的名称已回到`ed`，而且`fake_user`已被踢出会话：

    sql>>> session.rollback()plain
    ROLLBACK

    sql>>> ed_user.name
    BEGIN (implicit)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.id = ?
    (1,)
    u'ed'
    >>> fake_user in session
    False

发出 SELECT 说明对数据库所做的更改：

    sql>>> session.query(User).filter(User.name.in_(['ed', 'fakeuser'])).all()plain
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name IN (?, ?)
    ('ed', 'fakeuser')
    [<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>]

查询[¶](#querying "Permalink to this headline")
-----------------------------------------------

使用[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")上的[`query()`](session_api.html#sqlalchemy.orm.session.Session.query "sqlalchemy.orm.session.Session.query")方法创建[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")对象。此函数采用可变数量的参数，参数可以是类或者类的描述的集合。下面，我们指示加载`User`实例的[`查询`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")。下面是一个迭代输出`User`类的例子：

    sql>>> for instance in session.query(User).order_by(User.id):plain
    ...     print(instance.name, instance.fullname)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users ORDER BY users.id
    ()
    ed Ed Jones
    wendy Wendy Williams
    mary Mary Contrary
    fred Fred Flinstone

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")也接受 ORM 描述作为参数。任何时候，多个类实体或基于列的实体表达都可以作为[`query()`](session_api.html#sqlalchemy.orm.session.Session.query "sqlalchemy.orm.session.Session.query")函数的参数，返回类型为元组：

    sql>>> for name, fullname in session.query(User.name, User.fullname):plainplain
    ...     print(name, fullname)
    SELECT users.name AS users_name,
            users.fullname AS users_fullname
    FROM users
    ()
    ed Ed Jones
    wendy Wendy Williams
    mary Mary Contrary
    fred Fred Flinstone

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")返回的元组是*命名为*tuples，由[`KeyedTuple`](query.html#sqlalchemy.util.KeyedTuple "sqlalchemy.util.KeyedTuple")类提供，可以像普通 Python 对象一样对待。名称与属性的属性名称以及类的类名相同：

    sql>>> for row in session.query(User, User.name).all():
    ...    print(row.User, row.name)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    ()
    <User(name='ed', fullname='Ed Jones', password='f8s7ccs')> ed
    <User(name='wendy', fullname='Wendy Williams', password='foobar')> wendy
    <User(name='mary', fullname='Mary Contrary', password='xxg527')> mary
    <User(name='fred', fullname='Fred Flinstone', password='blah')> fred

您可以使用[`label()`](core_sqlelement.html#sqlalchemy.sql.expression.ColumnElement.label "sqlalchemy.sql.expression.ColumnElement.label")结构控制单个列表达式的名称，该结构可从任何[`ColumnElement`](core_sqlelement.html#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
- 来源对象，以及任何映射到实体表的列元素（例如`User.name`）：

    sql>>> for row in session.query(User.name.label('name_label')).all():
    ...    print(row.name_label)
    SELECT users.name AS name_label
    FROM users
    ()ed
    wendy
    mary
    fred

假设在对[`query()`](session_api.html#sqlalchemy.orm.session.Session.query "sqlalchemy.orm.session.Session.query")的调用中存在多个实体，可以使用[`aliased()`](query.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")来控制完整实体例如`User`：

    >>> from sqlalchemy.orm import aliased
    >>> user_alias = aliased(User, name='user_alias')

    sql>>> for row in session.query(user_alias, user_alias.name).all():
    ...    print(row.user_alias)
    SELECT user_alias.id AS user_alias_id,
            user_alias.name AS user_alias_name,
            user_alias.fullname AS user_alias_fullname,
            user_alias.password AS user_alias_password
    FROM users AS user_alias
    ()<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>
    <User(name='wendy', fullname='Wendy Williams', password='foobar')>
    <User(name='mary', fullname='Mary Contrary', password='xxg527')>
    <User(name='fred', fullname='Fred Flinstone', password='blah')>

使用[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")的基本操作包括发出 LIMIT 和 OFFSET，最方便地使用 Python 数组分片，通常与 ORDER
BY 结合使用：

    sql>>> for u in session.query(User).order_by(User.id)[1:3]:plain
    ...    print(u)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users ORDER BY users.id
    LIMIT ? OFFSET ?
    (2, 1)<User(name='wendy', fullname='Wendy Williams', password='foobar')>
    <User(name='mary', fullname='Mary Contrary', password='xxg527')>

过滤结果，可通过使用[`filter_by()`](query.html#sqlalchemy.orm.query.Query.filter_by "sqlalchemy.orm.query.Query.filter_by")（使用关键字参数）完成：

    sql>>> for name, in session.query(User.name).\plain
    ...             filter_by(fullname='Ed Jones'):
    ...    print(name)
    SELECT users.name AS users_name FROM users
    WHERE users.fullname = ?
    ('Ed Jones',)
    ed

...或[`filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")，它使用更灵活的 SQL 表达式语言结构。这些允许您在映射类上使用带有类级属性的常规 Python 运算符：

    sql>>> for name, in session.query(User.name).\plainplain
    ...             filter(User.fullname=='Ed Jones'):
    ...    print(name)
    SELECT users.name AS users_name FROM users
    WHERE users.fullname = ?
    ('Ed Jones',)
    ed

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")对象完全**生成**，这意味着大多数方法调用返回一个新的[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")对象，可以在其上添加更多的标准。例如，要查询名为“ed”的用户名为“Ed
Jones”的用户，可以调用[`filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")两次，使用`AND`连接标准：

    sql>>> for user in session.query(User).\plainplain
    ...          filter(User.name=='ed').\
    ...          filter(User.fullname=='Ed Jones'):
    ...    print(user)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ? AND users.fullname = ?
    ('ed', 'Ed Jones')
    <User(name='ed', fullname='Ed Jones', password='f8s7ccs')>

### 常用过滤器操作符[¶](#common-filter-operators "Permalink to this headline")

下面是[`filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")中使用的一些最常见的运算符：

-   [`equals`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__eq__ "sqlalchemy.sql.operators.ColumnOperators.__eq__")

        query.filter(User.name == 'ed')plainplainplain

-   [`not equals`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.__ne__ "sqlalchemy.sql.operators.ColumnOperators.__ne__")：

        query.filter(User.name != 'ed')

-   [`LIKE`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.like "sqlalchemy.sql.operators.ColumnOperators.like")

        query.filter(User.name.like('%ed%'))plainplainplain

-   [`IN`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.in_ "sqlalchemy.sql.operators.ColumnOperators.in_")

        query.filter(User.name.in_(['ed', 'wendy', 'jack']))plainplain

        # works with query objects too:
        query.filter(User.name.in_(
                session.query(User.name).filter(User.name.like('%ed%'))
        ))

-   [`NOT IN`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.notin_ "sqlalchemy.sql.operators.ColumnOperators.notin_")：

        query.filter(~User.name.in_(['ed', 'wendy', 'jack']))

-   [`IS NULL`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.is_ "sqlalchemy.sql.operators.ColumnOperators.is_")：

        query.filter(User.name == None)plain

        # alternatively, if pep8/linters are a concern
        query.filter(User.name.is_(None))

-   [`IS NOT NULL`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.isnot "sqlalchemy.sql.operators.ColumnOperators.isnot")：

        query.filter(User.name != None)

        # alternatively, if pep8/linters are a concern
        query.filter(User.name.isnot(None))

-   [`AND`](core_sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")

        # use and_()plainplain
        from sqlalchemy import and_
        query.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones'))

        # or send multiple expressions to .filter()
        query.filter(User.name == 'ed', User.fullname == 'Ed Jones')

        # or chain multiple filter()/filter_by() calls
        query.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones')

> 注意
>
> 确保使用[`and_()`](core_sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")而**不是**
> Python `and`运算符！

-   [`OR`](core_sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")

        from sqlalchemy import or_
        query.filter(or_(User.name == 'ed', User.name == 'wendy'))

> 注意
>
> 请确保使用[`or_()`](core_sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")而**不是**
> Python `or`运算符！

-   [`MATCH`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match "sqlalchemy.sql.operators.ColumnOperators.match")

        query.filter(User.name.match('wendy'))plainplainplain

> 注意
>
> [`match()`](core_sqlelement.html#sqlalchemy.sql.operators.ColumnOperators.match "sqlalchemy.sql.operators.ColumnOperators.match")使用数据库特定的`MATCH`或`CONTAINS`函数；其行为将随后端而变化，并且在某些后端（如 SQLite）上不可用。

### 返回列表和标量[¶](#returning-lists-and-scalars "Permalink to this headline")

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")上的多个方法会立即发出 SQL，并返回包含已加载数据库结果的值。这里是一个简短的介绍：

-   [`all()`](query.html#sqlalchemy.orm.query.Query.all "sqlalchemy.orm.query.Query.all")返回一个列表：

        >>> query = session.query(User).filter(User.name.like('%ed')).order_by(User.id)plain
        sql>>> query.all()
        SELECT users.id AS users_id,
                users.name AS users_name,
                users.fullname AS users_fullname,
                users.password AS users_password
        FROM users
        WHERE users.name LIKE ? ORDER BY users.id
        ('%ed',)
        [<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>,
              <User(name='fred', fullname='Fred Flinstone', password='blah')>]

-   [`first()`](query.html#sqlalchemy.orm.query.Query.first "sqlalchemy.orm.query.Query.first")应用一个限制，并将第一个结果作为标量返回：

        sql>>> query.first()
        SELECT users.id AS users_id,
                users.name AS users_name,
                users.fullname AS users_fullname,
                users.password AS users_password
        FROM users
        WHERE users.name LIKE ? ORDER BY users.id
         LIMIT ? OFFSET ?
        ('%ed', 1, 0)
        <User(name='ed', fullname='Ed Jones', password='f8s7ccs')>

-   [`one()`](query.html#sqlalchemy.orm.query.Query.one "sqlalchemy.orm.query.Query.one")完全获取所有行，如果结果中不存在一个对象标识或是有复合行，则会引发错误。找到多行：

        >>> user = query.one()
        Traceback (most recent call last):
        ...
        MultipleResultsFound: Multiple rows were found for one()

    没有找到行：

        >>> user = query.filter(User.id == 99).one()
        Traceback (most recent call last):
        ...
        NoResultFound: No row was found for one()

    [`one()`](query.html#sqlalchemy.orm.query.Query.one "sqlalchemy.orm.query.Query.one")方法非常适用于希望处理“没有找到项目”和“找到多个项目”的系统；例如 Web 服务返回，当没有找到结果时，它可能想要引发“404 未找到”，但是在找到多个结果时引发应用程序错误。

-   [`one_or_none()`](query.html#sqlalchemy.orm.query.Query.one_or_none "sqlalchemy.orm.query.Query.one_or_none")就像[`one()`](query.html#sqlalchemy.orm.query.Query.one "sqlalchemy.orm.query.Query.one")，除了如果没有找到结果，它不会引发错误；它只返回`None`。像[`one()`](query.html#sqlalchemy.orm.query.Query.one "sqlalchemy.orm.query.Query.one")，如果找到多个结果，它会引发错误。

-   [`scalar()`](query.html#sqlalchemy.orm.query.Query.scalar "sqlalchemy.orm.query.Query.scalar")调用[`one()`](query.html#sqlalchemy.orm.query.Query.one "sqlalchemy.orm.query.Query.one")方法，在 one()成功的基础上返回该行的第一列：

        >>> query = session.query(User.id).filter(User.name == 'ed').\plain
        ...    order_by(User.id)
        sql>>> query.scalar()
        SELECT users.id AS users_id
        FROM users
        WHERE users.name = ? ORDER BY users.id
        ('ed',)
        1

### 使用文本 SQL [¶](#using-textual-sql "Permalink to this headline")

文本字符串可以通过[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")灵活使用，通过[`text()`](core_sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")构造指定字符串的使用，这种方法可以用在很多方法中。例如，[`filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")和[`order_by()`](query.html#sqlalchemy.orm.query.Query.order_by "sqlalchemy.orm.query.Query.order_by")：

    >>> from sqlalchemy import text
    sql>>> for user in session.query(User).\
    ...             filter(text("id<224")).\
    ...             order_by(text("id")).all():
    ...     print(user.name)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE id<224 ORDER BY id
    ()
    ed
    wendy
    mary
    fred

绑定参数可以使用基于字符串的 SQL 指定，使用冒号。使用[`params()`](query.html#sqlalchemy.orm.query.Query.params "sqlalchemy.orm.query.Query.params")方法指定数值：

    sql>>> session.query(User).filter(text("id<:value and name=:name")).\
    ...     params(value=224, name='fred').order_by(User.id).one()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE id<? and name=? ORDER BY users.id
    (224, 'fred')
    <User(name='fred', fullname='Fred Flinstone', password='blah')>

要使用一个完整的 SQL 语句，可以将表示完整语句的[`text()`](core_sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")结构传递给[`from_statement()`](query.html#sqlalchemy.orm.query.Query.from_statement "sqlalchemy.orm.query.Query.from_statement")。如果没有其他说明符，字符串 SQL 中的列将根据名称与模型列匹配，如下所示，我们只使用星号来表示加载所有列：

    sql>>> session.query(User).from_statement(plainplain
    ...                     text("SELECT * FROM users where name=:name")).\
    ...                     params(name='ed').all()
    SELECT * FROM users where name=?
    ('ed',)
    [<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>]

名称匹配列适用于简单情况，但在处理包含重复列名的复杂语句时或使用不易与特定名称匹配的匿名 ORM 构造时，可能会变得不方便。另外，在处理结果行时，我们可能会发现映射列中存在打字行为。对于这些情况，[`text()`](core_sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")结构允许我们将其文本 SQL 链接到 Core 或 ORM 映射的列表达式；我们可以通过将列表达式作为位置参数传递到[`TextClause.columns()`](core_sqlelement.html#sqlalchemy.sql.expression.TextClause.columns "sqlalchemy.sql.expression.TextClause.columns")方法来实现：

    >>> stmt = text("SELECT name, id, fullname, password "
    ...             "FROM users where name=:name")
    >>> stmt = stmt.columns(User.name, User.id, User.fullname, User.password)
    sql>>> session.query(User).from_statement(stmt).params(name='ed').all()
    SELECT name, id, fullname, password FROM users where name=?
    ('ed',)
    [<User(name='ed', fullname='Ed Jones', password='f8s7ccs')>]

版本 1.1 中的新功能： [`TextClause.columns()`](core_sqlelement.html#sqlalchemy.sql.expression.TextClause.columns "sqlalchemy.sql.expression.TextClause.columns")方法现在接受与明文 SQL 结果集位置匹配的列表达式，匹配或甚至在 SQL 语句中是唯一的。

When selecting from a [`text()`](core_sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
construct, the [`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")
may still specify what columns and entities are to be returned; instead
of `query(User)` we can also ask for the columns
individually, as in any other case:

    >>> stmt = text("SELECT name, id FROM users where name=:name")
    >>> stmt = stmt.columns(User.name, User.id)
    sql>>> session.query(User.id, User.name).\
    ...          from_statement(stmt).params(name='ed').all()
    SELECT name, id FROM users where name=?
    ('ed',)
    [(1, u'ed')]

也可以看看

[Using Textual SQL](core_tutorial.html#sqlexpression-text) -
从纯核查询的角度解释[`text()`](core_sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")结构。

### 计数[¶ T0\>](#counting "Permalink to this headline")

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")包含一个用于计数的简便方法，称为[`count()`](query.html#sqlalchemy.orm.query.Query.count "sqlalchemy.orm.query.Query.count")：

    sql>>> session.query(User).filter(User.name.like('%ed')).count()plain
    SELECT count(*) AS count_1
    FROM (SELECT users.id AS users_id,
                    users.name AS users_name,
                    users.fullname AS users_fullname,
                    users.password AS users_password
    FROM users
    WHERE users.name LIKE ?) AS anon_1
    ('%ed',)
    2

依靠`count()`进行计数

[`Query.count()`](query.html#sqlalchemy.orm.query.Query.count "sqlalchemy.orm.query.Query.count")
used to be a very complicated method when it would try to guess whether
or not a subquery was needed around the existing query, and in some
exotic cases it wouldn’t do the right thing.
现在它每次都使用一个简单的子查询，它只有两行，总是返回正确的答案。如果某个特定语句绝对不能容忍子查询存在，请使用`func.count()`。

使用[`count()`](query.html#sqlalchemy.orm.query.Query.count "sqlalchemy.orm.query.Query.count")方法来确定 SQL 语句将返回多少行。查看上面生成的 SQL，SQLAlchemy 总是将我们正在查询的任何东西放到子查询中，然后对其进行计数。在某些情况下，这可以简化为`SELECT count（*） FROM 表  t0>，但现代版本的SQLAlchemy不会尝试猜测这是否合适，因为可以使用更明确的方法发出确切的SQL。`

For situations where the “thing to be counted” needs to be indicated
specifically, we can specify the “count” function directly using the
expression `func.count()`, available from the
[`func`](core_sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
construct. 下面我们用它来返回每个不同用户名的计数：

    >>> from sqlalchemy import funcplain
    sql>>> session.query(func.count(User.name), User.name).group_by(User.name).all()
    SELECT count(users.name) AS count_1, users.name AS users_name
    FROM users GROUP BY users.name
    ()
    [(1, u'ed'), (1, u'fred'), (1, u'mary'), (1, u'wendy')]

要实现我们简单的`SELECT count（*） FROM 表`它作为：

    sql>>> session.query(func.count('*')).select_from(User).scalar()plain
    SELECT count(?) AS count_1
    FROM users
    ('*',)
    4

如果我们直接使用`User`主键表示计数，则可以删除[`select_from()`](query.html#sqlalchemy.orm.query.Query.select_from "sqlalchemy.orm.query.Query.select_from")的用法：

    sql>>> session.query(func.count(User.id)).scalar()plainplain
    SELECT count(users.id) AS count_1
    FROM users
    ()
    4

建立关系[¶](#building-a-relationship "Permalink to this headline")
------------------------------------------------------------------

我们考虑如何映射和查询与`User`相关的第二张表。系统中的用户可以存储与其用户名相关联的任意数量的电子邮件地址。这意味着`用户`到存储电子邮件地址的新表(`addresses`)的一对多的关联。使用声明式，我们定义了这个表及其映射类`Address`：

    >>> from sqlalchemy import ForeignKeyplainplain
    >>> from sqlalchemy.orm import relationship

    >>> class Address(Base):
    ...     __tablename__ = 'addresses'
    ...     id = Column(Integer, primary_key=True)
    ...     email_address = Column(String, nullable=False)
    ...     user_id = Column(Integer, ForeignKey('users.id'))
    ...
    ...     user = relationship("User", back_populates="addresses")
    ...
    ...     def __repr__(self):
    ...         return "<Address(email_address='%s')>" % self.email_address

    >>> User.addresses = relationship(
    ...     "Address", order_by=Address.id, back_populates="user")

上面的类介绍了[`ForeignKey`](core_constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")的构造，它是一个应用于[`Column`](core_metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的指令，表示该列中的值应该是[受制于](glossary.html#term-constrained)在 User 表中的值。这是关系数据库的一个核心功能，并且是一种“粘合剂”，它可以转换一系列未连接的表，以获得丰富的重叠关系。上面的[`ForeignKey`](core_constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")表示`addresses.user_id`列中的值应该被限制为`users.id`列中的值，即其主键。

第二个指令称为[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")，告诉ORM：`Address`类本身应该链接到`User`类，使用属性`Address.user`[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")使用两个表之间的外键关系来确定这个链接的性质，确定`Address.user`将[many to
one](glossary.html#term-many-to-one)在属性`User.addresses`下的`User`映射类上放置了一个额外的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")指令。In
both [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
directives, the parameter [`relationship.back_populates`(relationship_api.html#sqlalchemy.orm.relationship.params.back_populates "sqlalchemy.orm.relationship")
is assigned to refer to the complementary attribute names; by doing so,
each [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
can make intelligent decision about the same relationship as expressed
in reverse; on one side, `Address.user` refers to a
`User` instance, and on the other side,
`User.addresses` refers to a list of
`Address` instances.

注意

[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates "sqlalchemy.orm.relationship")参数是称为[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref "sqlalchemy.orm.relationship")的非常常见的 SQLAlchemy 功能的更新版本。[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref "sqlalchemy.orm.relationship")参数没有消失，并且始终保持可用！[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates "sqlalchemy.orm.relationship")是同样的事情，除了稍微冗长一些并且更容易操作。有关整个主题的概述，请参阅[Linking
Relationships with Backref](backref.html#relationships-backref)部分。

多对一关系的反面总是[one to
many](glossary.html#term-one-to-many)。[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")配置的完整目录位于[Basic
Relationship Patterns](basic_relationships.html#relationship-patterns)。

两个互补关系`Address.user`和`User.addresses`被称为[bidirectional
relationship](glossary.html#term-bidirectional-relationship)，并且是 SQLAlchemy
ORM 的一个关键特性。[Linking Relationships with
Backref](backref.html#relationships-backref)部分详细讨论了“backref”功能。

假设 Declarative 系统正在使用，可以使用字符串指定涉及远程类的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的参数。一旦所有映射完成后，这些字符串将被评估为Python表达式，以便产生实际的参数，在上面的例子中是`User`类。在评估过程中允许的名称除其他外包括所有已根据声明的基础创建的类的名称。

有关参数样式的更多详细信息，请参阅[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的文档字符串。

你知道吗 ？

-   大多数（尽管不是全部）关系数据库中的 FOREIGN
    KEY 约束只能链接到主键列或具有 UNIQUE 约束的列。
-   引用多列主键并且自身具有多列的 FOREIGN
    KEY 约束被称为“组合外键”。它也可以引用这些列的一个子集。
-   FOREIGN
    KEY 列可以自动更新自己，以响应引用的列或行的更改。这被称为 CASCADE
    *引用操作*，并且是关系数据库的内置函数。
-   FOREIGN KEY可以引用它自己的表。这被称为“自我参照”外键。
-   在[外键 -
    维基百科](http://en.wikipedia.org/wiki/Foreign_key)中阅读有关外键的更多信息。

我们需要在数据库中创建`addresses`表，因此我们将从我们的元数据中发出另一个 CREATE，这将跳过已经创建的表：

    sql>>> Base.metadata.create_all(engine)plain
    PRAGMA...
    CREATE TABLE addresses (
        id INTEGER NOT NULL,
        email_address VARCHAR NOT NULL,
        user_id INTEGER,
        PRIMARY KEY (id),
         FOREIGN KEY(user_id) REFERENCES users (id)
    )
    ()
    COMMIT

使用相关对象[¶](#working-with-related-objects "Permalink to this headline")
---------------------------------------------------------------------------

现在当我们创建一个`User`时，一个空白的`addresses`集合将出现。各种集合类型（例如集合和字典）都可以在此处获得（详细信息请参阅[Customizing
Collection
Access](collections.html#custom-collections)），但默认情况下，集合是Python列表。

    >>> jack = User(name='jack', fullname='Jack Bean', password='gjffdd')plain
    >>> jack.addresses
    []

我们可以在`User`对象上自由添加`Address`对象。在这种情况下，我们直接指定一个完整列表：

    >>> jack.addresses = [
    ...                 Address(email_address='jack@google.com'),
    ...                 Address(email_address='j25@yahoo.com')]

当使用双向关系时，在一个方向上添加的元素会自动在另一个方向上可见。此行为基于属性 on-change 事件而发生，并且在 Python 中进行评估，而不使用任何 SQL：

    >>> jack.addresses[1]plain
    <Address(email_address='j25@yahoo.com')>

    >>> jack.addresses[1].user
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>

让我们向数据库添加并提交`Jack Bean`。`jack`以及相应`addresses`集合中的两个`Address`成员都会使用名为**级联
T6\>：**

    >>> session.add(jack)plainplain
    sql>>> session.commit()
    INSERT INTO users (name, fullname, password) VALUES (?, ?, ?)
    ('jack', 'Jack Bean', 'gjffdd')
    INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
    ('jack@google.com', 5)
    INSERT INTO addresses (email_address, user_id) VALUES (?, ?)
    ('j25@yahoo.com', 5)
    COMMIT

询问杰克，我们只得到杰克。尚未针对 Jack 的地址发布 SQL：

    sql>>> jack = session.query(User).\
    ... filter_by(name='jack').one()
    BEGIN (implicit)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ?
    ('jack',)

    >>> jack
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>

我们来看一下`addresses`集合。观看 SQL：

    sql>>> jack.addressesplain
    SELECT addresses.id AS addresses_id,
            addresses.email_address AS
            addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE ? = addresses.user_id ORDER BY addresses.id
    (5,)
    [<Address(email_address='jack@google.com')>, <Address(email_address='j25@yahoo.com')>]

当我们访问`addresses`集合时，SQL 突然发布。这是[lazy
loading](glossary.html#term-lazy-loading)关系的一个例子。`addresses`集合现在已加载，其行为与普通列表类似。我们将介绍如何优化这个集合的加载。

用连接查询[¶](#querying-with-joins "Permalink to this headline")
----------------------------------------------------------------

既然我们有两个表，我们可以展示[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")的更多特性，特别是如何创建同时处理两个表的查询。SQL
JOIN 上的[维基百科页面提供了一个很好的介绍连接技术的方法，其中几个我们将在这里进行说明。](http://en.wikipedia.org/wiki/Join_%28SQL%29)

To construct a simple implicit join between `User`
and `Address`, we can use [`Query.filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")
to equate their related columns together.
下面我们使用这个方法一次加载`User`和`Address`实体：

    sql>>> for u, a in session.query(User, Address).\plainplain
    ...                     filter(User.id==Address.user_id).\
    ...                     filter(Address.email_address=='jack@google.com').\
    ...                     all():
    ...     print(u)
    ...     print(a)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            addresses.id AS addresses_id,
            addresses.email_address AS addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM users, addresses
    WHERE users.id = addresses.user_id
            AND addresses.email_address = ?
    ('jack@google.com',)
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>
    <Address(email_address='jack@google.com')>

另一方面，实际的 SQL JOIN 语法最容易使用[`Query.join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")方法实现：

    sql>>> session.query(User).join(Address).\plain
    ...         filter(Address.email_address=='jack@google.com').\
    ...         all()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users JOIN addresses ON users.id = addresses.user_id
    WHERE addresses.email_address = ?
    ('jack@google.com',)
    [<User(name='jack', fullname='Jack Bean', password='gjffdd')>]

[`Query.join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")知道如何在`User`和`Address`之间进行连接，因为它们之间只有一个外键。如果没有外键或多个外键，当使用下列形式之一时，[`Query.join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")效果更好：

    query.join(Address, User.id==Address.user_id)    # explicit conditionplainplain
    query.join(User.addresses)                       # specify relationship from left to right
    query.join(Address, User.addresses)              # same, with explicit target
    query.join('addresses')                          # same, using a string

正如你所期望的那样，使用[`outerjoin()`](query.html#sqlalchemy.orm.query.Query.outerjoin "sqlalchemy.orm.query.Query.outerjoin")函数对“外部”连接使用相同的想法：

    query.outerjoin(User.addresses)   # LEFT OUTER JOINplain

[`join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")的参考文档包含此方法接受的调用样式的详细信息和示例；
[`join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")是任何 SQL 流利应用程序使用中心的重要方法。

如果有多个实体，[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")选择什么？

The [`Query.join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")
method will **typically join from the leftmost item** in the list of
entities, when the ON clause is omitted, or if the ON clause is a plain
SQL expression.
要控制 JOIN 列表中的第一个实体，请使用[`Query.select_from()`](query.html#sqlalchemy.orm.query.Query.select_from "sqlalchemy.orm.query.Query.select_from")方法：

    query = Session.query(User, Address).select_from(Address).join(User)plain

### 使用别名[¶](#using-aliases "Permalink to this headline")

When querying across multiple tables, if the same table needs to be
referenced more than once, SQL typically requires that the table be
*aliased* with another name, so that it can be distinguished against
other occurrences of that table. [`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")使用[`aliased`](query.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")结构最明确地支持这一点。下面我们加入`Address`实体两次，以找到同时拥有两个不同电子邮件地址的用户：

    >>> from sqlalchemy.orm import aliased
    >>> adalias1 = aliased(Address)
    >>> adalias2 = aliased(Address)
    sql>>> for username, email1, email2 in \
    ...     session.query(User.name, adalias1.email_address, adalias2.email_address).\
    ...     join(adalias1, User.addresses).\
    ...     join(adalias2, User.addresses).\
    ...     filter(adalias1.email_address=='jack@google.com').\
    ...     filter(adalias2.email_address=='j25@yahoo.com'):
    ...     print(username, email1, email2)
    SELECT users.name AS users_name,
            addresses_1.email_address AS addresses_1_email_address,
            addresses_2.email_address AS addresses_2_email_address
    FROM users JOIN addresses AS addresses_1
            ON users.id = addresses_1.user_id
    JOIN addresses AS addresses_2
            ON users.id = addresses_2.user_id
    WHERE addresses_1.email_address = ?
            AND addresses_2.email_address = ?
    ('jack@google.com', 'j25@yahoo.com')
    jack jack@google.com j25@yahoo.com

### 使用子查询[¶](#using-subqueries "Permalink to this headline")

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")适用于生成可用作子查询的语句。假设我们想要加载`User`对象以及每个用户拥有多少个`Address`记录的计数。像这样生成 SQL 的最佳方法是获取按用户标识分组的地址数，并将 JOIN 添加到父级。在这种情况下，我们使用 LEFT
OUTER JOIN，以便我们返回那些没有任何地址的用户的行，例如：

    SELECT users.*, adr_count.address_count FROM users LEFT OUTER JOINplain
        (SELECT user_id, count(*) AS address_count
            FROM addresses GROUP BY user_id) AS adr_count
        ON users.id=adr_count.user_id

使用[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")，我们从内到外构建一个类似于此的语句。`statement`访问器返回一个表达由特定[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")生成的语句的 SQL 表达式
- 这是一个[`select()`](core_selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造的实例，它们分别是描述在[SQL
Expression Language Tutorial](core_tutorial.html)中：

    >>> from sqlalchemy.sql import funcplain
    >>> stmt = session.query(Address.user_id, func.count('*').\
    ...         label('address_count')).\
    ...         group_by(Address.user_id).subquery()

`func`关键字生成 SQL 函数，并且[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")上的`subquery()`方法生成一个 SQL 表达式结构，表示嵌入别名中的 SELECT 语句它实际上是`query.statement.alias()`的缩写）。

一旦我们有了我们的声明，它就像一个[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")结构，比如我们在本教程开始时为`users`创建的结构。语句中的列可以通过名为`c`的属性进行访问：

    sql>>> for u, count in session.query(User, stmt.c.address_count).\plainplain
    ...     outerjoin(stmt, User.id==stmt.c.user_id).order_by(User.id):
    ...     print(u, count)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            anon_1.address_count AS anon_1_address_count
    FROM users LEFT OUTER JOIN
        (SELECT addresses.user_id AS user_id, count(?) AS address_count
        FROM addresses GROUP BY addresses.user_id) AS anon_1
        ON users.id = anon_1.user_id
    ORDER BY users.id
    ('*',)
    <User(name='ed', fullname='Ed Jones', password='f8s7ccs')> None
    <User(name='wendy', fullname='Wendy Williams', password='foobar')> None
    <User(name='mary', fullname='Mary Contrary', password='xxg527')> None
    <User(name='fred', fullname='Fred Flinstone', password='blah')> None
    <User(name='jack', fullname='Jack Bean', password='gjffdd')> 2

### 从子查询中选择实体[¶](#selecting-entities-from-subqueries "Permalink to this headline")

上面，我们刚刚选择了一个包含子查询列的结果。如果我们希望我们的子查询映射到实体呢？为此，我们使用`aliased()`将映射类的“别名”关联到子查询：

    sql>>> stmt = session.query(Address).\plainplainplain
    ...                 filter(Address.email_address != 'j25@yahoo.com').\
    ...                 subquery()
    >>> adalias = aliased(Address, stmt)
    >>> for user, address in session.query(User, adalias).\
    ...         join(adalias, User.addresses):
    ...     print(user)
    ...     print(address)
    SELECT users.id AS users_id,
                users.name AS users_name,
                users.fullname AS users_fullname,
                users.password AS users_password,
                anon_1.id AS anon_1_id,
                anon_1.email_address AS anon_1_email_address,
                anon_1.user_id AS anon_1_user_id
    FROM users JOIN
        (SELECT addresses.id AS id,
                addresses.email_address AS email_address,
                addresses.user_id AS user_id
        FROM addresses
        WHERE addresses.email_address != ?) AS anon_1
        ON users.id = anon_1.user_id
    ('j25@yahoo.com',)
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>
    <Address(email_address='jack@google.com')>

### 使用 EXISTS [¶](#using-exists "Permalink to this headline")

SQL 中的 EXISTS 关键字是一个布尔运算符，如果给定表达式包含任何行，则返回 True。它可以在许多场景中用于代替连接，并且对于查找在相关表中没有相应行的行也很有用。

有一个明确的 EXISTS 构造，看起来像这样：

    >>> from sqlalchemy.sql import existsplainplainplain
    >>> stmt = exists().where(Address.user_id==User.id)
    sql>>> for name, in session.query(User.name).filter(stmt):
    ...     print(name)
    SELECT users.name AS users_name
    FROM users
    WHERE EXISTS (SELECT *
    FROM addresses
    WHERE addresses.user_id = users.id)
    ()
    jack

[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")具有几个自动使用 EXISTS 的操作符。以上，语句可以使用[`any()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any "sqlalchemy.orm.properties.RelationshipProperty.Comparator.any")沿着`User.addresses`关系表示：

    sql>>> for name, in session.query(User.name).\plain
    ...         filter(User.addresses.any()):
    ...     print(name)
    SELECT users.name AS users_name
    FROM users
    WHERE EXISTS (SELECT 1
    FROM addresses
    WHERE users.id = addresses.user_id)
    ()
    jack

[`any()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any "sqlalchemy.orm.properties.RelationshipProperty.Comparator.any")
takes criterion as well, to limit the rows matched:

    sql>>> for name, in session.query(User.name).\plainplain
    ...     filter(User.addresses.any(Address.email_address.like('%google%'))):
    ...     print(name)
    SELECT users.name AS users_name
    FROM users
    WHERE EXISTS (SELECT 1
    FROM addresses
    WHERE users.id = addresses.user_id AND addresses.email_address LIKE ?)
    ('%google%',)
    jack

[`has()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.has "sqlalchemy.orm.properties.RelationshipProperty.Comparator.has")
is the same operator as [`any()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any "sqlalchemy.orm.properties.RelationshipProperty.Comparator.any")
for many-to-one relationships (note the `~` operator
here too, which means “NOT”):

    sql>>> session.query(Address).\plain
    ...         filter(~Address.user.has(User.name=='jack')).all()
    SELECT addresses.id AS addresses_id,
            addresses.email_address AS addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE NOT (EXISTS (SELECT 1
    FROM users
    WHERE users.id = addresses.user_id AND users.name = ?))
    ('jack',)
    []

### 常见关系运算符[¶](#common-relationship-operators "Permalink to this headline")

以下是所有基于关系的运营商 -
每个运营商都链接到其 API 文档，其中包含使用和行为的全部详细信息：

-   [`__eq__()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.__eq__ "sqlalchemy.orm.properties.RelationshipProperty.Comparator.__eq__")（多对一“等于”比较）：

        query.filter(Address.user == someuser)plain

-   [`__ne__()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.__ne__ "sqlalchemy.orm.properties.RelationshipProperty.Comparator.__ne__")（多对一“不等于”比较）：

        query.filter(Address.user != someuser)plainplain

-   IS NULL（多对一比较，也使用[`__eq__()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.__eq__ "sqlalchemy.orm.properties.RelationshipProperty.Comparator.__eq__")）：

        query.filter(Address.user == None)

-   [`contains()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.contains "sqlalchemy.orm.properties.RelationshipProperty.Comparator.contains")（用于一对多集合）：

        query.filter(User.addresses.contains(someaddress))plainplain

-   [`any()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.any "sqlalchemy.orm.properties.RelationshipProperty.Comparator.any")（用于集合）：

        query.filter(User.addresses.any(Address.email_address == 'bar'))

        # also takes keyword arguments:
        query.filter(User.addresses.any(email_address='bar'))

-   [`has()`](internals.html#sqlalchemy.orm.properties.RelationshipProperty.Comparator.has "sqlalchemy.orm.properties.RelationshipProperty.Comparator.has")（用于标量引用）：

        query.filter(Address.user.has(name='ed'))plainplain

-   [`Query.with_parent()`](query.html#sqlalchemy.orm.query.Query.with_parent "sqlalchemy.orm.query.Query.with_parent")
    (used for any relationship):

        session.query(Address).with_parent(someuser, 'addresses')plainplain

急于加载[¶](#eager-loading "Permalink to this headline")
--------------------------------------------------------

回想一下，当我们访问`User`的`User.addresses`集合并发射了 SQL 时，我们演示了一个[lazy
loading](glossary.html#term-lazy-loading)操作。如果你想减少查询的数量（在很多情况下是显着的），我们可以在查询操作中应用一个预先加载。SQLAlchemy 提供了三种热切加载类型，其中两种是自动加载的，另一种是自定义标准。通常通过称为查询选项的函数调用所有这三个函数，这些函数为[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")提供了有关如何通过[`Query.options()`](query.html#sqlalchemy.orm.query.Query.options "sqlalchemy.orm.query.Query.options")方法。

### 子查询 Load [¶](#subquery-load "Permalink to this headline")

在这种情况下，我们希望指出`User.addresses`应该急切加载。加载一组对象及其相关集合的好选择是[`orm.subqueryload()`](loading_relationships.html#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")选项，该选项发出第二个 SELECT 语句，该语句完全加载与刚加载的结果相关的集合。名称“subquery”源自直接通过[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")构造的 SELECT 语句被重用，并作为子查询嵌入到 SELECT 中以对照相关表。这有点复杂但很容易使用：

    >>> from sqlalchemy.orm import subqueryload
    sql>>> jack = session.query(User).\
    ...                 options(subqueryload(User.addresses)).\
    ...                 filter_by(name='jack').one()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ?
    ('jack',)
    SELECT addresses.id AS addresses_id,
            addresses.email_address AS addresses_email_address,
            addresses.user_id AS addresses_user_id,
            anon_1.users_id AS anon_1_users_id
    FROM (SELECT users.id AS users_id
        FROM users WHERE users.name = ?) AS anon_1
    JOIN addresses ON anon_1.users_id = addresses.user_id
    ORDER BY anon_1.users_id, addresses.id
    ('jack',)
    >>> jack
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>

    >>> jack.addresses
    [<Address(email_address='jack@google.com')>, <Address(email_address='j25@yahoo.com')>]

注意

[`subqueryload()`](loading_relationships.html#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")
when used in conjunction with limiting such as [`Query.first()`](query.html#sqlalchemy.orm.query.Query.first "sqlalchemy.orm.query.Query.first"),
[`Query.limit()`](query.html#sqlalchemy.orm.query.Query.limit "sqlalchemy.orm.query.Query.limit")
or [`Query.offset()`](query.html#sqlalchemy.orm.query.Query.offset "sqlalchemy.orm.query.Query.offset")
should also include [`Query.order_by()`](query.html#sqlalchemy.orm.query.Query.order_by "sqlalchemy.orm.query.Query.order_by")
on a unique column in order to ensure correct results. 请参阅[The
Importance of
Ordering](loading_relationships.html#subqueryload-ordering)。

### 加入 Load [¶](#joined-load "Permalink to this headline")

另一个自动加载加载函数更为人熟知，称为[`orm.joinedload()`](loading_relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")。这种加载方式会发出一个 JOIN，默认情况下是一个 LEFT
OUTER
JOIN，这样就可以在一个步骤中加载前导对象以及相关的对象或集合。我们举例说明以这种方式加载相同的`addresses`集合 - 请注意，即使`jack`上的`User.addresses`集合现在实际上已被填充，无论如何查询都会发出额外的连接：

    >>> from sqlalchemy.orm import joinedload

    sql>>> jack = session.query(User).\
    ...                        options(joinedload(User.addresses)).\
    ...                        filter_by(name='jack').one()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            addresses_1.id AS addresses_1_id,
            addresses_1.email_address AS addresses_1_email_address,
            addresses_1.user_id AS addresses_1_user_id
    FROM users
        LEFT OUTER JOIN addresses AS addresses_1 ON users.id = addresses_1.user_id
    WHERE users.name = ? ORDER BY addresses_1.id
    ('jack',)

    >>> jack
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>

    >>> jack.addresses
    [<Address(email_address='jack@google.com')>, <Address(email_address='j25@yahoo.com')>]

请注意，即使 OUTER JOIN 导致了两行，我们仍然只返回一个`User`的实例。这是因为[`Query`](query.html#sqlalchemy.orm.query.Query "sqlalchemy.orm.query.Query")将基于对象标识的“uniquing”策略应用于返回的实体。这特别适用于可以应用加入的加载加载而不影响查询结果。

虽然[`joinedload()`](loading_relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")已经存在了很长时间，但是[`subqueryload()`](loading_relationships.html#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")是一种更新的渴望加载形式。[`subqueryload()`](loading_relationships.html#sqlalchemy.orm.subqueryload "sqlalchemy.orm.subqueryload")倾向于更加适合加载相关集合，而[`joinedload()`](loading_relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")倾向于更适合于多对一关系，因为只有一个对于领导和相关对象都加载行。

`joinedload()`不能代替`join()`

由[`joinedload()`](loading_relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")创建的连接是匿名化的，因此它**不会影响查询结果**。[`Query.order_by()`](query.html#sqlalchemy.orm.query.Query.order_by "sqlalchemy.orm.query.Query.order_by")或[`Query.filter()`](query.html#sqlalchemy.orm.query.Query.filter "sqlalchemy.orm.query.Query.filter")调用**不能**引用这些别名表
- 构建所谓的“用户空间”联接使用[`Query.join()`](query.html#sqlalchemy.orm.query.Query.join "sqlalchemy.orm.query.Query.join")。其基本原理是，[`joinedload()`](loading_relationships.html#sqlalchemy.orm.joinedload "sqlalchemy.orm.joinedload")仅适用于影响相关对象或集合作为优化细节加载的方式
-
可以添加或删除它，而不会影响实际结果。有关如何使用这些内容的详细说明，请参阅[The
Zen of Eager
Loading](loading_relationships.html#zen-of-eager-loading)部分。

### 显式加入+ Eagerload [¶](#explicit-join-eagerload "Permalink to this headline")

第三种急切加载方式是当我们为了定位主要行而显式构建一个 JOIN 时，并且想额外将额外表应用到主要对象上的相关对象或集合。此功能通过[`orm.contains_eager()`](loading_relationships.html#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")函数提供，通常用于在需要过滤同一对象的查询上预加载多对一对象。下面我们将说明如何加载`Address`行以及相关的`User`对象，在名为“jack”的`User`上进行过滤并使用[`orm.contains_eager()`](loading_relationships.html#sqlalchemy.orm.contains_eager "sqlalchemy.orm.contains_eager")将“user”列应用于`Address.user`属性：

    >>> from sqlalchemy.orm import contains_eagerplain
    sql>>> jacks_addresses = session.query(Address).\
    ...                             join(Address.user).\
    ...                             filter(User.name=='jack').\
    ...                             options(contains_eager(Address.user)).\
    ...                             all()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password,
            addresses.id AS addresses_id,
            addresses.email_address AS addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM addresses JOIN users ON users.id = addresses.user_id
    WHERE users.name = ?
    ('jack',)

    >>> jacks_addresses
    [<Address(email_address='jack@google.com')>, <Address(email_address='j25@yahoo.com')>]

    >>> jacks_addresses[0].user
    <User(name='jack', fullname='Jack Bean', password='gjffdd')>

有关预加载的更多信息，包括如何默认配置各种加载形式，请参阅[*Relationship
Loading Techniques*](loading_relationships.html)部分。

删除[¶ T0\>](#deleting "Permalink to this headline")
----------------------------------------------------

让我们试着删除`jack`，看看结果如何。我们将在会话中标记为已删除，然后我们将发出一个`count`查询以查看没有行保留：

    >>> session.delete(jack)plain
    sql>>> session.query(User).filter_by(name='jack').count()
    UPDATE addresses SET user_id=? WHERE addresses.id = ?
    ((None, 1), (None, 2))
    DELETE FROM users WHERE users.id = ?
    (5,)
    SELECT count(*) AS count_1
    FROM (SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ?) AS anon_1
    ('jack',)
    0

到现在为止还挺好。杰克的`Address`对象怎么样？

    sql>>> session.query(Address).filter(plainplain
    ...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
    ...  ).count()
    SELECT count(*) AS count_1
    FROM (SELECT addresses.id AS addresses_id,
                    addresses.email_address AS addresses_email_address,
                    addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE addresses.email_address IN (?, ?)) AS anon_1
    ('jack@google.com', 'j25@yahoo.com')
    2

呃哦，他们还在！分析刷新 SQL，我们可以看到每个地址的`user_id`列设置为 NULL，但行未被删除。SQLAlchemy 不会假设删除级联，你必须告诉它这样做。

### 配置删除/删除 - 孤立级联[¶](#configuring-delete-delete-orphan-cascade "Permalink to this headline")

我们将在`User.addresses`关系上配置**级联**选项来更改行为。尽管 SQLAlchemy 允许您在任何时间点添加新的属性和关系到映射，但在这种情况下，需要删除现有的关系，因此我们需要完全拆除映射并重新开始
- 我们将关闭[`Session`](session_api.html#sqlalchemy.orm.session.Session "sqlalchemy.orm.session.Session")

    >>> session.close()
    ROLLBACK

并使用新的[`declarative_base()`](extensions_declarative_api.html#sqlalchemy.ext.declarative.declarative_base "sqlalchemy.ext.declarative.declarative_base")：

    >>> Base = declarative_base()plain

接下来，我们将声明`User`类，并在包含级联配置的`addresses`关系中添加（我们将离开构造函数）：

    >>> class User(Base):plainplainplain
    ...     __tablename__ = 'users'
    ...
    ...     id = Column(Integer, primary_key=True)
    ...     name = Column(String)
    ...     fullname = Column(String)
    ...     password = Column(String)
    ...
    ...     addresses = relationship("Address", back_populates='user',
    ...                     cascade="all, delete, delete-orphan")
    ...
    ...     def __repr__(self):
    ...        return "<User(name='%s', fullname='%s', password='%s')>" % (
    ...                                self.name, self.fullname, self.password)

然后我们重新创建`Address`，注意在这种情况下，我们已经通过`User`类创建了`Address.user`关系：

    >>> class Address(Base):
    ...     __tablename__ = 'addresses'
    ...     id = Column(Integer, primary_key=True)
    ...     email_address = Column(String, nullable=False)
    ...     user_id = Column(Integer, ForeignKey('users.id'))
    ...     user = relationship("User", back_populates="addresses")
    ...
    ...     def __repr__(self):
    ...         return "<Address(email_address='%s')>" % self.email_address

现在当我们加载用户`jack`（下面用[`get()`](query.html#sqlalchemy.orm.query.Query.get "sqlalchemy.orm.query.Query.get")，通过主键加载），从相应的`addresses`集合中删除一个地址将导致`Address`被删除：

    # load Jack by primary keyplain
    sql>>> jack = session.query(User).get(5)
    BEGIN (implicit)
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.id = ?
    (5,)

    # remove one Address (lazy load fires off)
    sql>>> del jack.addresses[1]
    SELECT addresses.id AS addresses_id,
            addresses.email_address AS addresses_email_address,
            addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE ? = addresses.user_id
    (5,)

    # only one address remains
    sql>>> session.query(Address).filter(
    ...     Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
    ... ).count()
    DELETE FROM addresses WHERE addresses.id = ?
    (2,)
    SELECT count(*) AS count_1
    FROM (SELECT addresses.id AS addresses_id,
                    addresses.email_address AS addresses_email_address,
                    addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE addresses.email_address IN (?, ?)) AS anon_1
    ('jack@google.com', 'j25@yahoo.com')
    1

删除 Jack 将删除 Jack 和与用户关联的其余`Address`：

    >>> session.delete(jack)plain

    sql>>> session.query(User).filter_by(name='jack').count()
    DELETE FROM addresses WHERE addresses.id = ?
    (1,)
    DELETE FROM users WHERE users.id = ?
    (5,)
    SELECT count(*) AS count_1
    FROM (SELECT users.id AS users_id,
                    users.name AS users_name,
                    users.fullname AS users_fullname,
                    users.password AS users_password
    FROM users
    WHERE users.name = ?) AS anon_1
    ('jack',)
    0

    sql>>> session.query(Address).filter(
    ...    Address.email_address.in_(['jack@google.com', 'j25@yahoo.com'])
    ... ).count()
    SELECT count(*) AS count_1
    FROM (SELECT addresses.id AS addresses_id,
                    addresses.email_address AS addresses_email_address,
                    addresses.user_id AS addresses_user_id
    FROM addresses
    WHERE addresses.email_address IN (?, ?)) AS anon_1
    ('jack@google.com', 'j25@yahoo.com')
    0

更多关于瀑布

有关级联配置的更多详细信息，请参见[Cascades](cascades.html#unitofwork-cascades)。级联功能还可以与关系数据库的`ON DELETE CASCADE`功能顺利集成。有关详细信息，请参见[Using Passive
Deletes](collections.html#passive-deletes)。

建立多对多的关系[¶](#building-a-many-to-many-relationship "Permalink to this headline")
---------------------------------------------------------------------------------------

我们正在进入奖金轮，但让我们展示一个多对多的关系。我们也会潜入一些其他功能，只是为了参观。我们将使我们的应用程序成为博客应用程序，用户可以在其中编写`BlogPost`项目，其中包含与`Keyword`项目相关联的项目。

对于普通的多对多，我们需要创建一个未映射的[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")结构来充当关联表。这看起来像下面这样：

    >>> from sqlalchemy import Table, Textplainplain
    >>> # association table
    >>> post_keywords = Table('post_keywords', Base.metadata,
    ...     Column('post_id', ForeignKey('posts.id'), primary_key=True),
    ...     Column('keyword_id', ForeignKey('keywords.id'), primary_key=True)
    ... )

上面，我们可以看到直接声明一个[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")与声明一个映射类有点不同。[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")是一个构造函数，所以每个[`Column`](core_metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")参数都以逗号分隔。[`Column`](core_metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象也显式给出其名称，而不是从已分配的属性名称中获取。

接下来，我们使用互补的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")结构定义`BlogPost`和`Keyword`，每个结构都引用`post_keywords`表作为关联表：

    >>> class BlogPost(Base):
    ...     __tablename__ = 'posts'
    ...
    ...     id = Column(Integer, primary_key=True)
    ...     user_id = Column(Integer, ForeignKey('users.id'))
    ...     headline = Column(String(255), nullable=False)
    ...     body = Column(Text)
    ...
    ...     # many to many BlogPost<->Keyword
    ...     keywords = relationship('Keyword',
    ...                             secondary=post_keywords,
    ...                             back_populates='posts')
    ...
    ...     def __init__(self, headline, body, author):
    ...         self.author = author
    ...         self.headline = headline
    ...         self.body = body
    ...
    ...     def __repr__(self):
    ...         return "BlogPost(%r, %r, %r)" % (self.headline, self.body, self.author)


    >>> class Keyword(Base):
    ...     __tablename__ = 'keywords'
    ...
    ...     id = Column(Integer, primary_key=True)
    ...     keyword = Column(String(50), nullable=False, unique=True)
    ...     posts = relationship('BlogPost',
    ...                          secondary=post_keywords,
    ...                          back_populates='keywords')
    ...
    ...     def __init__(self, keyword):
    ...         self.keyword = keyword

注意

上面的类声明说明了显式的`__init__()`方法。请记住，使用声明时，它是可选的！

Above, the many-to-many relationship is `BlogPost.keywords`. 多对多关系的定义特征是引用代表关联表的[`Table`](core_metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象的`secondary`关键字参数。This table only contains columns which reference
the two sides of the relationship; if it has *any* other columns, such
as its own primary key, or foreign keys to other tables, SQLAlchemy
requires a different usage pattern called the “association object”,
described at [Association
Object](basic_relationships.html#association-pattern).

我们还希望我们的`BlogPost`类具有`author`字段。我们会将此添加为另一种双向关系，除了我们将要面对的一个问题是单个用户可能拥有大量博客帖子。当我们访问`User.posts`时，我们希望能够进一步过滤结果，以免加载整个集合。为此，我们使用一个名为`lazy='dynamic'`的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")接受的设置，该设置在属性上配置了一个备用**加载器策略**

    >>> BlogPost.author = relationship(User, back_populates="posts")plain
    >>> User.posts = relationship(BlogPost, back_populates="author", lazy="dynamic")

创建新表格：

    sql>>> Base.metadata.create_all(engine)plain
    PRAGMA...
    CREATE TABLE keywords (
        id INTEGER NOT NULL,
        keyword VARCHAR(50) NOT NULL,
        PRIMARY KEY (id),
        UNIQUE (keyword)
    )
    ()
    COMMIT
    CREATE TABLE posts (
        id INTEGER NOT NULL,
        user_id INTEGER,
        headline VARCHAR(255) NOT NULL,
        body TEXT,
        PRIMARY KEY (id),
        FOREIGN KEY(user_id) REFERENCES users (id)
    )
    ()
    COMMIT
    CREATE TABLE post_keywords (
        post_id INTEGER NOT NULL,
        keyword_id INTEGER NOT NULL,
        PRIMARY KEY (post_id, keyword_id),
        FOREIGN KEY(post_id) REFERENCES posts (id),
        FOREIGN KEY(keyword_id) REFERENCES keywords (id)
    )
    ()
    COMMIT

用法与我们所做的并无太大差别。让我们给温蒂一些博客文章：

    sql>>> wendy = session.query(User).\
    ...                 filter_by(name='wendy').\
    ...                 one()
    SELECT users.id AS users_id,
            users.name AS users_name,
            users.fullname AS users_fullname,
            users.password AS users_password
    FROM users
    WHERE users.name = ?
    ('wendy',)
    >>> post = BlogPost("Wendy's Blog Post", "This is a test", wendy)
    >>> session.add(post)

我们将关键字唯一地存储在数据库中，但我们知道我们还没有，所以我们可以创建它们：

    >>> post.keywords.append(Keyword('wendy'))
    >>> post.keywords.append(Keyword('firstpost'))

现在我们可以使用关键字'firstpost'查找所有博客文章。我们将使用`any`运算符来定位“任何关键字具有关键字字符串”firstpost“的博客帖子：

    sql>>> session.query(BlogPost).\
    ...             filter(BlogPost.keywords.any(keyword='firstpost')).\
    ...             all()
    INSERT INTO keywords (keyword) VALUES (?)
    ('wendy',)
    INSERT INTO keywords (keyword) VALUES (?)
    ('firstpost',)
    INSERT INTO posts (user_id, headline, body) VALUES (?, ?, ?)
    (2, "Wendy's Blog Post", 'This is a test')
    INSERT INTO post_keywords (post_id, keyword_id) VALUES (?, ?)
    (...)
    SELECT posts.id AS posts_id,
            posts.user_id AS posts_user_id,
            posts.headline AS posts_headline,
            posts.body AS posts_body
    FROM posts
    WHERE EXISTS (SELECT 1
        FROM post_keywords, keywords
        WHERE posts.id = post_keywords.post_id
            AND keywords.id = post_keywords.keyword_id
            AND keywords.keyword = ?)
    ('firstpost',)
    [BlogPost("Wendy's Blog Post", 'This is a test', <User(name='wendy', fullname='Wendy Williams', password='foobar')>)]

如果我们想查找由用户`wendy`拥有的帖子，我们可以告诉查询将其缩小为`User`对象作为父级：

    sql>>> session.query(BlogPost).\
    ...             filter(BlogPost.author==wendy).\
    ...             filter(BlogPost.keywords.any(keyword='firstpost')).\
    ...             all()
    SELECT posts.id AS posts_id,
            posts.user_id AS posts_user_id,
            posts.headline AS posts_headline,
            posts.body AS posts_body
    FROM posts
    WHERE ? = posts.user_id AND (EXISTS (SELECT 1
        FROM post_keywords, keywords
        WHERE posts.id = post_keywords.post_id
            AND keywords.id = post_keywords.keyword_id
            AND keywords.keyword = ?))
    (2, 'firstpost')
    [BlogPost("Wendy's Blog Post", 'This is a test', <User(name='wendy', fullname='Wendy Williams', password='foobar')>)]

或者我们可以使用 Wendy 自己的`posts`关系，这是一个“动态”关系，从这里直接查询：

    sql>>> wendy.posts.\plainplain
    ...         filter(BlogPost.keywords.any(keyword='firstpost')).\
    ...         all()
    SELECT posts.id AS posts_id,
            posts.user_id AS posts_user_id,
            posts.headline AS posts_headline,
            posts.body AS posts_body
    FROM posts
    WHERE ? = posts.user_id AND (EXISTS (SELECT 1
        FROM post_keywords, keywords
        WHERE posts.id = post_keywords.post_id
            AND keywords.id = post_keywords.keyword_id
            AND keywords.keyword = ?))
    (2, 'firstpost')
    [BlogPost("Wendy's Blog Post", 'This is a test', <User(name='wendy', fullname='Wendy Williams', password='foobar')>)]

进一步参考[¶](#further-reference "Permalink to this headline")
--------------------------------------------------------------

查询参考：query\_api\_toplevel

映射器参考：[Mapper Configuration](mapper_config.html)

关系参考：[Relationship Configuration](relationships.html)

会话参考：[*Using the Session*](session.html)
