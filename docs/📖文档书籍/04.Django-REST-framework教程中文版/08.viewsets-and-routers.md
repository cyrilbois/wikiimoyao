---
title: 教程 6：ViewSets 和 Routers
date: 2021-04-13 10:29:01
permalink: /drf-tutorial/viewsets-and-routers/
categories:
  - 📖文档书籍
  - Django-REST-framework 教程中文版
tags:
  - DRF
---

REST framework 提供了一种叫做`ViewSets`的抽象行为，它可以使开发人员聚焦于 API 的状态和实现，基于常见的约定而自动进行 URL 配置。

`ViewSet`和`View`很像，除了它提供的是`read`以及`update`操作而不是 HTTP 的`get`或者`post`。

`ViewSet`仅在被调用的时候才会和对应的方法进行绑定，当它被实例化时——通常是在使用`Route`类管理 URL 配置的时候。

使用 ViewSet 重构代码
-------------

首先我们使用但一个`UserViewSet`来取代`UserList`和`UserDetail`，我们先移除那两个类，并添加：

    from rest_framework import viewsetsplainplainplain
    
    class UserViewSet(viewsets.ReadOnlyModelViewSet):
        """
        This viewset automatically provides `list` and `detail` actions.
        """
        queryset = User.objects.all()
        serializer_class = UserSerializer
    

现在我们使用`ReadOnlyModelViewSet`自动提供了“只读”方法，并且依然想使用常规视图是那样设置了`queryset`和`seriallizer_class`属性，但我们不需要写 2 个类了。

下面我们修改`SnippetList`、`SnippetDetail`和`SnippetHighlight`类，同样删除它们并修改成一个类：

    from rest_framework.decorators import detail_routeplainplainplainplainplain
    
    class SnippetViewSet(viewsets.ModelViewSet):
        """
        This viewset automatically provides `list`, `create`, `retrieve`,
        `update` and `destroy` actions.
    
        Additionally we also provide an extra `highlight` action.
        """
        queryset = Snippet.objects.all()
        serializer_class = SnippetSerializer
        permission_classes = (permissions.IsAuthenticatedOrReadOnly,
                              IsOwnerOrReadOnly,)
    
        @detail_route(renderer_classes=[renderers.StaticHTMLRenderer])
        def highlight(self, request, *args, **kwargs):
            snippet = self.get_object()
            return Response(snippet.highlighted)
    
        def perform_create(self, serializer):
            serializer.save(owner=self.request.user)
    

这次我们使用`ModelViewSet`来获取完整的读和写操作。注意我们使用`@detail_route`装饰器来创建自定义动作，这个装饰器可以用于任何不符合标准`create/update/delete`的动作。

使用`@detail_route`装饰的用户自定义动作默认相应 GET 请求，如果需要响应 POST 操作需要指定`methods`参数。

默认情况下，自定义动作对应的 URL 取决于它们的函数名，也可以通过给装饰器传递`url_path`参数来进行修改。

显式绑定 URL 和 ViewSets
----------------

仅仅在我们定义 URL 配置时 HTTP 方法才会和我们定义的行为进行绑定。为了理解细节，我们先显式的在`urls.py`中进行操作：

    from snippets.views import SnippetViewSet, UserViewSet, api_rootplainplainplain
    from rest_framework import renderers
    
    snippet_list = SnippetViewSet.as_view({
        'get': 'list',
        'post': 'create'
    })
    snippet_detail = SnippetViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'patch': 'partial_update',
        'delete': 'destroy'
    })
    snippet_highlight = SnippetViewSet.as_view({
        'get': 'highlight'
    }, renderer_classes=[renderers.StaticHTMLRenderer])
    user_list = UserViewSet.as_view({
        'get': 'list'
    })
    user_detail = UserViewSet.as_view({
        'get': 'retrieve'
    })
    

注意我们为每个`ViewSet`都创建了多个 View，并且为每个 View 的行为和 HTTP 方法进行了绑定。

绑定后，我们可以像平常那样定义 URL：

    urlpatterns = format_suffix_patterns([plainplainplainplainplainplain
        url(r'^$', api_root),
        url(r'^snippets/$', snippet_list, name='snippet-list'),
        url(r'^snippets/(?P<pk>[0-9]+)/$', snippet_detail, name='snippet-detail'),
        url(r'^snippets/(?P<pk>[0-9]+)/highlight/$', snippet_highlight, name='snippet-highlight'),
        url(r'^users/$', user_list, name='user-list'),
        url(r'^users/(?P<pk>[0-9]+)/$', user_detail, name='user-detail')
    ])
    

使用 Routers
---------

因为我们使用了`ViewSet`而不是`View`，实际上我们不需要自己定义 URL。使用`Router`类可以自动的进行上述操作，我们需要做的仅仅是正确的注册 View 到 Router 中：

    from django.conf.urls import url, includeplainplainplain
    from snippets import views
    from rest_framework.routers import DefaultRouter
    
    # Create a router and register our viewsets with it.
    router = DefaultRouter()
    router.register(r'snippets', views.SnippetViewSet)
    router.register(r'users', views.UserViewSet)
    
    # The API URLs are now determined automatically by the router.
    # Additionally, we include the login URLs for the browsable API.
    urlpatterns = [
        url(r'^', include(router.urls)),
        url(r'^api-auth/', include('rest_framework.urls', namespace='rest_framework'))
    ]
    

使用 route 生成了相同的 URL 路径，我们包含了 2 个参数——URL 前缀以及 Viewset 本身。

`DefaultRouter`类自动创建了根 URL，所以也可以在`views`中移除`api_root`了。

权衡 Views 和 Viewsets
----------------

viewsets 是一种很用的抽象，它帮助我们确保 URL 符合惯例，减少代码编写量，使你专注于 API 交互和设计而不是 URL 配置上。

但这并不意味这总是一种好的选择，就好象函数视图和类视图之间的权衡一样，使用 viewsets 相比于显示构建 vews，有些隐晦。

总结
--

通过少量的代码，我们构建出一个完备的 Web API,完美支持浏览器访问、用户认证、权限管理，并且支持多种返回格式。

我们经历了每步设计的过程，并且知道了如果我们需要自定义功能，可以方便的使用 Django 原生的 views.

你可以在[github](https://github.com/tomchristie/rest-framework-tutorial)上找到最终的代码，以及[模拟程序](http://restframework.herokuapp.com/)。

展望
--

整个教程到这就结束了，如果你想得到更多信息，这里有几点建议：

*   在[Github](https://github.com/tomchristie/django-rest-framework)提问并且提交 pull requests。
*   加入[REST framework discussion 组](https://groups.google.com/forum/?fromgroups target=)并为社区做贡献。
*   在 Twitter 上跟随[作者](https://twitter.com/_tomchristie)并 say hi。