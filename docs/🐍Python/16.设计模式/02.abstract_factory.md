---
title: python工厂模式 抽象工厂模式
date: 2017-12-05 00:00:00
tags: 
  - 设计模式
categories: 设计模式
permalink: /python/patterns/abstract_factory/
---

## TL;DR

Provides a way to encapsulate a group of individual factories.

## 基本思想和原则

工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。

为创建一组相关或相互依赖的对象提供一组接口，而且无须指定它们的具体类。

高层模块不应直接依赖低层模块，应该依赖其抽象，工厂就是这个抽象。

## 动机

让我们考虑产品族和产品类型这两个概念。举个产品族的例子，苹果和戴尔两家公司都生产计算机，计算机是一种统称，是一个抽象概念，这是产品族。其中计算机又可以分为服务器、台式机、笔记本等，这是计算机的类型，一个具体概念，这是产品类型。因此产品族和产品类型的对比如下表：

|  名称  | 抽象/具体 | 概念方向
|:------------------|:------------------|:------------------
| 产品族  | 抽象 | 横向
| 产品类型  | 具体 | 纵向

## 实现

```python
"""
*What is this pattern about?

In Java and other languages, the Abstract Factory Pattern serves to provide an interface for
creating related/dependent objects without need to specify their
actual class.

The idea is to abstract the creation of objects depending on business
logic, platform choice, etc.

In Python, the interface we use is simply a callable, which is "builtin" interface
in Python, and in normal circumstances we can simply use the class itself as
that callable, because classes are first class objects in Python.

*What does this example do?
This particular implementation abstracts the creation of a pet and
does so depending on the factory we chose (Dog or Cat, or random_animal)
This works because both Dog/Cat and random_animal respect a common
interface (callable for creation and .speak()).
Now my application can create pets abstractly and decide later,
based on my own criteria, dogs over cats.

*Where is the pattern used practically?

*References:
https://sourcemaking.com/design_patterns/abstract_factory
http://ginstrom.com/scribbles/2007/10/08/design-patterns-python-style/

*TL;DR
Provides a way to encapsulate a group of individual factories.
"""

import random
from typing import Type


class Pet:
    def __init__(self, name: str) -> None:
        self.name = name

    def speak(self) -> None:
        raise NotImplementedError

    def __str__(self) -> str:
        raise NotImplementedError


class Dog(Pet):
    def speak(self) -> None:
        print("woof")

    def __str__(self) -> str:
        return f"Dog<{self.name}>"


class Cat(Pet):
    def speak(self) -> None:
        print("meow")

    def __str__(self) -> str:
        return f"Cat<{self.name}>"


class PetShop:

    """A pet shop"""

    def __init__(self, animal_factory: Type[Pet]) -> None:
        """pet_factory is our abstract factory.  We can set it at will."""

        self.pet_factory = animal_factory

    def buy_pet(self, name: str) -> Pet:
        """Creates and shows a pet using the abstract factory"""

        pet = self.pet_factory(name)
        print(f"Here is your lovely {pet}")
        return pet


# Additional factories:

# Create a random animal
def random_animal(name: str) -> Pet:
    """Let's be dynamic!"""
    return random.choice([Dog, Cat])(name)


# Show pets with various factories
def main() -> None:
    """
    # A Shop that sells only cats
    >>> cat_shop = PetShop(Cat)
    >>> pet = cat_shop.buy_pet("Lucy")
    Here is your lovely Cat<Lucy>
    >>> pet.speak()
    meow

    # A shop that sells random animals
    >>> shop = PetShop(random_animal)
    >>> for name in ["Max", "Jack", "Buddy"]:
    ...    pet = shop.buy_pet(name)
    ...    pet.speak()
    ...    print("=" * 20)
    Here is your lovely Cat<Max>
    meow
    ====================
    Here is your lovely Dog<Jack>
    woof
    ====================
    Here is your lovely Dog<Buddy>
    woof
    ====================
    """


if __name__ == "__main__":
    random.seed(1234)  # for deterministic doctest outputs
    shop = PetShop(random_animal)
    import doctest

    doctest.testmod()

```

## 优点

封装性好，将高层模块和具体实现类解耦，高层模块不需要关心具体实现类的细节，只需要和工厂打交道，由工厂去创建对象。

## 缺点

抽象工厂模式很难对*产品族*进行扩展，也就是说，想要扩展产品族，就需要对原来的契约双方都做修改，很明显违反了开闭原则。

相反，使用抽象工厂模式对*产品类型*进行扩展要容易得多，可以发现使用抽象工厂模式扩展产品类型都是新增，不需要修改原来的代码，符合开闭原则。