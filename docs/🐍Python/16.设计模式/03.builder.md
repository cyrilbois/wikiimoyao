---
title: 建造者模式
date: 2017-12-08 00:00:00
tags: 
  - 设计模式
categories: 设计模式
permalink: /python/patterns/builder/
---

## TL;DR
Decouples the creation of a complex object and its representation.

对复杂对象的创建及其表示进行分离、解耦

## 基本思想和原则

将一个复杂对象的构建和它的表示分离，使同样的构建过程可以创建不同的表示。

使用 Builder 类封装类实例的创建过程，客户代码使用各个 Builder 来构建对象而不是直接使用 new 创建类实例。

## 动机

当一个类中某个方法中的内部调用顺序不同，会产生不同的结果时，可以考虑使用建造者模式。将产生特定调用顺序的类实例用 Builder 进行封装，供客户代码使用可以简化整个对象创建过程。当需要产生新的调用顺序地类实例时，只需要创建对应的 Builder 即可。

## 实现
```python
"""
*What is this pattern about?
It decouples the creation of a complex object and its representation,
so that the same process can be reused to build objects from the same
family.
This is useful when you must separate the specification of an object
from its actual representation (generally for abstraction).

*What does this example do?

The first example achieves this by using an abstract base
class for a building, where the initializer (__init__ method) specifies the
steps needed, and the concrete subclasses implement these steps.

In other programming languages, a more complex arrangement is sometimes
necessary. In particular, you cannot have polymorphic behaviour in a constructor in C++ -
see https://stackoverflow.com/questions/1453131/how-can-i-get-polymorphic-behavior-in-a-c-constructor
- which means this Python technique will not work. The polymorphism
required has to be provided by an external, already constructed
instance of a different class.

In general, in Python this won't be necessary, but a second example showing
this kind of arrangement is also included.

*Where is the pattern used practically?

*References:
https://sourcemaking.com/design_patterns/builder

*TL;DR
Decouples the creation of a complex object and its representation.
"""


# Abstract Building
class Building:
    def __init__(self) -> None:
        self.build_floor()
        self.build_size()

    def build_floor(self):
        raise NotImplementedError

    def build_size(self):
        raise NotImplementedError

    def __repr__(self) -> str:
        return "Floor: {0.floor} | Size: {0.size}".format(self)


# Concrete Buildings
class House(Building):
    def build_floor(self) -> None:
        self.floor = "One"

    def build_size(self) -> None:
        self.size = "Big"


class Flat(Building):
    def build_floor(self) -> None:
        self.floor = "More than One"

    def build_size(self) -> None:
        self.size = "Small"


# In some very complex cases, it might be desirable to pull out the building
# logic into another function (or a method on another class), rather than being
# in the base class '__init__'. (This leaves you in the strange situation where
# a concrete class does not have a useful constructor)


class ComplexBuilding:
    def __repr__(self) -> str:
        return "Floor: {0.floor} | Size: {0.size}".format(self)


class ComplexHouse(ComplexBuilding):
    def build_floor(self) -> None:
        self.floor = "One"

    def build_size(self) -> None:
        self.size = "Big and fancy"


def construct_building(cls) -> Building:
    building = cls()
    building.build_floor()
    building.build_size()
    return building


def main():
    """
    >>> house = House()
    >>> house
    Floor: One | Size: Big

    >>> flat = Flat()
    >>> flat
    Floor: More than One | Size: Small

    # Using an external constructor function:
    >>> complex_house = construct_building(ComplexHouse)
    >>> complex_house
    Floor: One | Size: Big and fancy
    """


if __name__ == "__main__":
    import doctest

    doctest.testmod()

```
ref:[patterns/creational/builder.py · imoyao/python-patterns - Gitee.com](https://gitee.com/imoyao/python-patterns/blob/master/patterns/creational/builder.py)

## 优点

建造者模式对一个类产生具体实例做了相应的封装，使客户代码不需要了解具体类的内部细节，可以直接使用相应的 Builder 来创建实例。各个 Builder 之间具有很好的隔离性，都可以独立做改变而不会互相影响。
