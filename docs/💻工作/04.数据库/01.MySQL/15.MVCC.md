---
title: MySQL 的 MVCC 机制
tags:
  - 面试
  - MySQL
categories:
  - 💻工作
  - MySQL
  - 面试
date: 2021-05-23 18:21:46 
permalink: /mysql/mvcc/
---
## 1 什么是 MVCC

MVCC 全称是： **Multiversion concurrency control**，多版本并发控制，提供并发访问数据库时，对事务内读取的到的内存做处理，用来避免写操作堵塞读操作的并发问题。

举个例子，程序员 A 正在读数据库中某些内容，而程序员 B 正在给这些内容做修改（假设是在一个事务内修改，大概持续 10s 左右），A 在这 10s 内 则可能看到一个不一致的数据，在 B 没有提交前，如何让 A 能够一直读到的数据都是一致的呢？

有几种处理方法，第一种： 基于锁的并发控制，程序员 B 开始修改数据时，给这些数据加上锁，程序员 A 这时再读，就发现读取不了，处于等待情况，只能等 B 操作完才能读数据，这保证 A 不会读到一个不一致的数据，但是这个会影响程序的运行效率。还有一种就是：MVCC，每个用户连接数据库时，看到的都是某一特定时刻的数据库快照，在 B 的事务没有提交之前，A 始终读到的是某一特定时刻的数据库快照，不会读到 B 事务中的数据修改情况，直到 B 事务提交，才会读取 B 的修改内容。

一个支持 MVCC 的数据库，在更新某些数据时，并非使用新数据覆盖旧数据，而是标记旧数据是过时的，同时在其他地方新增一个数据版本。因此，同一份数据有多个版本存储，但只有一个是最新的。

MVCC 提供了时间一致性的处理思路，在 MVCC 下读事务时，通常使用一个时间戳或者事务 ID 来确定访问哪个状态的数据库及哪些版本的数据。读事务跟写事务彼此是隔离开来的，彼此之间不会影响。假设同一份数据，既有读事务访问，又有写事务操作，实际上，写事务会新建一个新的数据版本，而读事务访问的是旧的数据版本，直到写事务提交，读事务才会访问到这个新的数据版本。

MVCC 有两种实现方式，第一种实现方式是将数据记录的多个版本保存在数据库中，当这些不同版本数据不再需要时，垃圾收集器回收这些记录。这个方式被 PostgreSQL 和 Firebird/Interbase 采用，SQL Server 使用的类似机制，所不同的是旧版本数据不是保存在数据库中，而保存在不同于主数据库的另外一个数据库 tempdb 中。第二种实现方式只在数据库保存最新版本的数据，但是会在使用 undo 时动态重构旧版本数据，这种方式被 Oracle 和 MySQL/InnoDB 使用。

### 当前读

像 select lock in share mode(共享锁), select for update ; update, insert ,delete(排他锁)这些操作都是一种当前读，为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。

### 快照读（提高数据库的并发查询能力）

像不加锁的 select 操作就是快照读，即不加锁的非阻塞读；快照读的前提是隔离级别不是串行级别，串行级别下的快照读会退化成当前读；之所以出现快照读的情况，是基于提高并发性能的考虑，快照读的实现是基于多版本并发控制，即 MVCC,可以认为 MVCC 是行锁的一个变种，但它在很多情况下，避免了加锁操作，降低了开销；既然是基于多版本，即快照读可能读到的并不一定是数据的最新版本，而有可能是之前的历史版本

### 当前读、快照读、MVCC 关系

MVCC 多版本并发控制指的是维持一个数据的多个版本，使得读写操作没有冲突，快照读是 MySQL 为实现 MVCC 的一个非阻塞读功能。MVCC 模块在 MySQL 中的具体实现是由三个隐式字段，undo 日志、read view 三个组件来实现的。

## 2、InnoDB 的 MVCC 实现机制

MVCC 可以认为是行级锁的一个变种，它可以在很多情况下避免加锁操作，因此开销更低。MVCC 的实现大都都实现了非阻塞的读操作，写操作也只锁定必要的行。InnoDB 的 MVCC 实现，是通过保存数据在某个时间点的快照来实现的。**一个事务，不管其执行多长时间，其内部看到的数据是一致的**。也就是事务在执行的过程中不会相互影响。下面我们简述一下 MVCC 在 InnoDB 中的实现。

InnoDB 的 MVCC，**通过在每行记录后面保存两个隐藏的列来实现：一个保存了行的创建时间，一个保存行的过期时间（删除时间），当然，这里的时间并不是时间戳，而是系统版本号，每开始一个新的事务，系统版本号就会递增**。在 RR 隔离级别下，MVCC 的操作如下：

1. select 操作。
    * **InnoDB 只查找版本早于（包含等于）当前事务版本的数据行**。可以确保事务读取的行，要么是事务开始前就已存在，或者事务自身插入或修改的记录。
    * **行的删除版本要么未定义，要么大于当前事务版本号**。可以确保事务读取的行，在事务开始之前未删除。
2. insert 操作。将新插入的行保存当前版本号为行版本号。
3. delete 操作。将删除的行保存当前版本号为删除标识。
4. update 操作。变为 insert 和 delete 操作的组合，insert 的行保存当前版本号为行版本号，delete 则保存当前版本号到原来的行作为删除标识。

由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb 会开启一个后台线程执行清理工作，具体的规则是**将删除版本号小于当前系统版本的行删除**，这个过程叫做 purge。

## 3、简单的小例子

```sql
create table yang( 
    id int primary key auto\_increment, 
    name varchar(20));
```

假设系统的版本号从 1 开始.

### INSERT

InnoDB 为新插入的每一行保存当前系统版本号作为版本号.
第一个事务 ID 为 1；

```sql
start transaction;
insert into yang values(NULL,'yang') ;
insert into yang values(NULL,'long');
insert into yang values(NULL,'fei');
commit;
```

对应在数据中的表如下(后面两列是隐藏列,我们通过查询语句并看不到)

![](https://pic.imgdb.cn/item/65163974c458853aefec532c.jpg)

### SELECT

InnoDB 会根据以下两个条件检查每行记录:  
a.InnoDB 只会查找版本早于当前事务版本的数据行(也就是,行的系统版本号小于或等于事务的系统版本号)，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的.  
b.行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除.  
　只有 a,b 同时满足的记录，才能返回作为查询结果.

### DELETE

In
noDB 会为删除的每一行保存当前系统的版本号(事务的 ID)作为删除标识.  
看下面的具体例子分析:  
第二个事务,ID 为 2;

```sql
start transaction;
select \* from yang;  //(1)
select \* from yang;  //(2)
commit; 
```

#### 　假设 1

假设在执行这个事务 ID 为 2 的过程中,刚执行到(1),这时,有另一个事务 ID 为 3 往这个表里插入了一条数据;
第三个事务 ID 为 3;

start transaction;
insert into yang values(NULL,'tian');
commit;

这时表中的数据如下:

![](https://pic.imgdb.cn/item/651639bac458853aefec5b1b.jpg)

然后接着执行事务 2 中的(2),由于 id=4 的数据的创建时间(事务 ID 为 3),执行当前事务的 ID 为 2,而 InnoDB 只会查找事务 ID 小于等于当前事务 ID 的数据行,所以 id=4 的数据行并不会在执行事务 2 中的(2)被检索出来,在事务 2 中的两条 select 语句检索出来的数据都只会下表:

![](https://pic.imgdb.cn/item/651639dcc458853aefec5fdd.jpg)

#### 假设 2

假设在执行这个事务 ID 为 2 的过程中,刚执行到(1),假设事务执行完事务 3 后，接着又执行了事务 4;
第四个事务:

```sql
start   transaction;  
delete from yang where id=1;
commit;  
```

此时数据库中的表如下:

![](https://pic.imgdb.cn/item/651639f9c458853aefec624f.jpg)

接着执行事务 ID 为 2 的事务(2),根据 SELECT 检索条件可以知道,它会检索创建时间(创建事务的 ID)小于当前事务 ID 的行和删除时间(删除事务的 ID)大于当前事务的行,而 id=4 的行上面已经说过,而 id=1 的行由于删除时间(删除事务的 ID)大于当前事务的 ID,所以事务 2 的(2)select * from yang 也会把 id=1 的数据检索出来.所以,事务 2 中的两条 select 语句检索出来的数据都如下:  
![](https://pic.imgdb.cn/item/65163a12c458853aefec6617.jpg)

### UPDATE

InnoDB 执行 UPDATE，实际上是新插入了一行记录，并保存其创建时间为当前事务的 ID，同时保存当前事务 ID 到要 UPDATE 的行的删除时间。

#### 假设 3

假设在执行完事务 2 的(1)后又执行,其它用户执行了事务 3,4,这时，又有一个用户对这张表执行了 UPDATE 操作:  
第 5 个事务:

```sql
start  transaction;
update yang set name\='Long' where id\=2;
commit;
```

根据 update 的更新原则:会生成新的一行,并在原来要修改的列的删除时间列上添加本事务 ID,得到表如下:

![](https://pic.imgdb.cn/item/65163c6dc458853aefeca75c.jpg)

继续执行事务 2 的(2),根据 select 语句的检索条件,得到下表:

![](https://pic.imgdb.cn/item/65163c8ac458853aefecaaa0.jpg)

还是和事务 2 中(1)select 得到相同的结果.

## 原文链接

1. [mysql 的 MVCC（多版本并发控制） - myseries - 博客园](https://www.cnblogs.com/myseries/p/10930910.html)
2. [Mysql-MVCC 多版本并发控制详解 - 掘金](https://juejin.cn/post/7090118565357387807)
