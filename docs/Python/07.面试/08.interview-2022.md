---
title:  2022 面试记录
date: 2022-03-22 13:56:51
permalink: /interview-2022/
categories:
  - 🐍Python
  - 面试
tags:
  - 面试
---

## 捷风数据

1. (问答题)以任何语言打印一个矩阵，输入是矩阵的行数 rowNum 和矩阵的列数 colNum,这里保证输入的必然是自然数，且小于 Integer.MAX 要求在命令行打印一个如下的蛇形矩阵：

```python
   >>> 3*5
   # 输出为:
   1,6,7,12,13
   2,5,8,11,14
   3,4,9,10,15
   
   >>> 2*2
   # 输出为:
   1, 4
   2, 3
```
要求实现的人提供一个 JAR 包或者一个 python 文件, 在命令行使用
```plain
python test.py 34
   
java -jar xxxjar 3 4.
```
来打印一个 3*4 的矩阵

## 深光科技

- 索引原理，回表查询，b+树和 b 树区别？为什么不使用红黑树/二叉树，聚簇索引
- redis 使用，集群选举制度
- WSGI 实现了什么？

web 服务器在将请求转交给 web 应用程序之前，需要先将 http 报文转换为 WSGI 规定的格式。

WSGI 规定，Web 程序必须有一个可调用对象，且该可调用对象接收两个参数，返回一个可迭代对象：

`environ`：字典，包含请求的所有信息
`start_response`：在可调用对象中调用的函数，用来发起响应，参数包括状态码，headers 等

- web.py、flask、django 技术选型为什么倾向于选用 flask，（面试官倾向于选择 Django）
- 事务
- flask 运行机制
- 基类，在哪看到过？
- 脑裂是什么？
- dict 的实现

  1. [python 源码分析：dict 对象的实现 - 木易小邪 - 博客园](https://www.cnblogs.com/muyiblog/p/7662262.html)
  2. [Python dictionary implementation – Laurent Luce's Blog](http://www.laurentluce.com/posts/python-dictionary-implementation/)
- celery 实际推荐使用 rabbitMQ，为什么？

  redis 不是一个真正的消息队列，我们只是把 list 当作消息队列来使用，而 rabbitMQ 实现了消息队列中的更多功能。

### 二面

- nginx 配置，字段含义 `$host`，还有哪些关键字？
- **iteritems，items 区别**？
  ```python
  # python2
  >>> a = {'a':1,'b':2}
  >>> b = a.iteritems()
  >>> type(b)
  <type 'dictionary-itemiterator'>
  >>> next(b)
  ('a', 1)
  ```

  在 python2 中`iteritems`返回的是迭代器。`items`返回的是列表

  ```python
  In [1]: a = {'a':1,'b':2}

  In [2]: b = a.items()

  In [3]: type(b)
  Out[3]: dict_items

  In [4]: next(b)
  ---------------------------------------------------------------------------
  TypeError                                 Traceback (most recent call last)
  <ipython-input-4-adb3e17b0219> in <module>
  ----> 1 next(b)

  TypeError: 'dict_items' object is not an iterator
  In [6]: c = iter(b)

  In [7]: next(c)
  Out[7]: ('a', 1)
  ```
  在 python3 中`items`返回的是可迭代对象。

- 多线程多进程编程？进程通信方式，queue 无法跳出，遇到过吗，如何解决的？
- 数据库索引优化举例？
- Python 底层加速
- 内存不足杀死进程如何调试？  
  埋点，打印 log、pdb 调试  
- 索引无效的情况都有哪些？
- 线上 linux 查看问题点的命令？
  netstat、top、lsof -i 、ps
- 各个 web 框架的区别或者优缺点？

## 集简慧通

- left join 与 right join

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/20200427222717175.png)

left join：顾名思义，就是“左连接”，表 1 左连接表 2，以左为主，表示以表 1 为主，关联上表 2 的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。

right join：“右连接”，表 1 右连接表 2，以右为主，表示以表 2 为主，关联查询表 1 的数据，查出表 2 所有数据以及表 1 和表 2 有交集的数据。

join：其实就是“inner join”，为了简写才写成 join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的。

- Django 的生命周期
- 静态方法和类方法的区别
- MySQL B+树索引和哈希索引的区别
![B+树索引](https://pic1.zhimg.com/80/v2-72887788846597b4577c9ff530033694_720w.jpg?source=1940ef5c)

B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过 1，而且同层级的节点间有指针相互链接。

在 B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。

![哈希索引](https://pic1.zhimg.com/80/v2-34889f812b2bb1fc1f107bebd342d50f_720w.jpg?source=1940ef5c)

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似 B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

如果是**等值查询，那么哈希索引明显有绝对优势**，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
从示意图中也能看到，**如果是范围查询检索，哈希索引就毫无用武之地**了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
同理，哈希索引也没办法利用索引完成排序，以及 `like "xxx%"` 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
哈希索引也不支持多列联合索引的最左匹配规则；
B+树索引的关键字检索效率比较平均，不像 B 树那样波动幅度大，在有**大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题**。


- 主键索引和唯一索引的区别

主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
唯一性索引列允许空值，而主键列不允许为空值。
主键可以被其他表引用为外键，而唯一索引不能。

一个表最多只能创建一个主键，但可以创建多个唯一索引。

- `__new__` 和`__init__`区别
- Python 传值还是传引用
- Python 是否支持重载

不支持，但是也不影响。因为 Python 可以处理这种问题。
 [python-中重载](/python/interview/#python-中重载)

- 闭包
- 迭代器与生成器
- 下划线和双下划线的区别

Python 中没有真正的私有属性，但是可以用这种方式来表示私有；但是单下划线可以强制导入，而双下划线只能通过`_ClassName__var`来获取。

## 龙创悦动

- token 的工作机制
- 索引、事务/innoDB 和 MyISAM 的对比

  事务：一个最小的不可再分的工作单元
- web 框架的对比

## 大地量子

- **range 返回的对象类型**
  
  Python3 `range()` 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。

  Python3 `list()` 函数是对象迭代器，可以把`range()`返回的可迭代对象转为一个列表，返回的变量类型为列表。

  python2 中`xrange`返回惰性可迭代对象，可以遍历而不消耗，类型为 `range`对象，而不是迭代器，无法使用`next`取值！有`len`方法

- python 版本问题
- 一行打印乘法口诀表
  
  列表生成式
- `__new__` 和`__init__`区别
- 聚集索引的概念，字段的数据类型，每页数据为什么是 16k，可以是 32k 吗？可以使用 uuid 作为聚簇索引的主键吗？
  
  增加 `page_size` 的大小：如改为 32k，64k。数据库的页块大小改变需要改动源码。

- 聚索引的顺序问题
  
  聚集索引不是物理上连续的，而是逻辑上连续的。（面试官怎么问这个问题的记不住了，好像是说先插入主键为 1，3，4，之后插入 2 是否可以插入？）

- 事务四大特性，之间是否存在关联？
  
  ACID，是否存在关联不知道。。。
- innoDB 和 MyISAM 的对比

1. innodb 支持事务
2. innoDB 支持行锁，MyISAM 只支持表锁
3. innoDB 支持外键
4. 数据恢复 innoDB 更快
  
- 生成器取元素的方式，除了 next 还有哪些？
- 新式类和经典类
- 垃圾回收机制

[Python 的内存管理与垃圾回收机制 | 别院牧志知识库](/python/mm-gc/)
```python
gc.get_threshold()
(700, 10, 10)
```
700 代表新创建的对象减去从新创建的对象中回收的数量的差值大于 700 就进行一次 0 代回收当 0 代回收进行 10 次的时候就进行一代回收（并且一代回收的时候也进行 0 代回收），同理，当一代回收进行 10 次的时候就进行 2  代回收（并且二代回收的时候也进行 0 代回收和一代回收）

## 众趣科技

- 三次握手，四次挥手
- 索引的原理
  顺序访问指针，所以查询快
- 怎么分析慢查询？
 explain 查询是否为全表扫描，是的话加索引
- 最左匹配原则？
- 乐观锁、悲观锁？
- 深拷贝，浅拷贝？
- gRPC 工作原理？
- 多态解释一下？
  [面向对象之封装、继承、多态 | 别院牧志知识库](/oop/encapsulate-inheritance-polymorphism/#%E5%A4%9A%E6%80%81)

### WSGI 与 ASGI

- 什么是 WSGI

先说一下`CGI`，（通用网关接口， Common Gateway Interface/CGI），定义客户端与 Web 服务器的交流方式的一个程序。例如正常情况下客户端发来一个请求，根据`HTTP`协议 Web 服务器将请求内容解析出来，经过计算后，再将内容封装好，例如服务器返回一个`HTML`页面，并且根据`HTTP`协议构建返回内容的响应格式。涉及到`TCP`连接、`HTTP`原始请求和相应格式的这些，都由一个软件来完成，这时，以上的工作需要一个程序来完成，而这个程序便是`CGI`。

那什么是`WSGI`呢？[维基](https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3) 上的解释为，**Web 服务器网关接口(Python Web Server Gateway Interface，WSGI)**，是为`Python`语言定义的 Web 服务器和 Web 应用程序或框架之间的一种简单而通用的接口。从语义上理解，貌似`WSGI`就是`Python`为了解决**Web 服务器端与客户端**之间的通信问题而产生的，并且`WSGI`是基于现存的`CGI`标准而设计的，同样是一种程序（或者`Web`组件的接口规范？）。

[WSGI](https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3) 区分为两部分：一种为“服务器”或“网关”，另一种为“应用程序”或“应用框架”。  

所谓的`WSGI`中间件同时实现了`API`的两方，即在`WSGI`服务器和`WSGI`应用之间起调解作用：从`WSGI`服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。中间件具有的功能：

*   重写环境变量后，根据目标 URL，将请求消息路由到不同的应用对象。
*   允许在一个进程中同时运行多个应用程序或应用框架
*   负载均衡和远程处理，通过在网络上转发请求和相应消息。
*   进行内容后处理，例如应用`XSLT`样式表。（以上 from 维基）

看了这么多，总结一下，其实可以说`WSGI`就是基于`Python`的以`CGI`为标准做一些扩展。

- 什么是[ASGI](https://blog.ernest.me/post/asgi-draft-spec-zh)

异步网关协议接口，一个介于网络协议服务和`Python`应用之间的标准接口，能够处理多种通用的协议类型，包括`HTTP`，`HTTP2`和`WebSocket`。  
然而目前的常用的`WSGI`主要是针对`HTTP`风格的请求响应模型做的设计，并且越来越多的不遵循这种模式的协议逐渐成为`Web`变成的标准之一，例如`WebSocket`。  
`ASGI`尝试保持在一个简单的应用接口的前提下，提供允许数据能够在任意的时候、被任意应用进程发送和接受的抽象。并且同样描述了一个新的，兼容`HTTP`请求响应以及`WebSocket`数据帧的序列格式。允许这些协议能通过网络或本地`socket`进行传输，以及让不同的协议被分配到不同的进程中。

- WSGI 和 ASGI 的区别在哪

以上，`WSGI`是基于`HTTP`协议模式的，不支持`WebSocket`，而`ASGI`的诞生则是为了解决`Python`常用的`WSGI`不支持当前`Web`开发中的一些新的协议标准。同时，`ASGI`对于`WSGI`原有的模式的支持和`WebSocket`的扩展，即`ASGI`是`WSGI`的扩展。

ref：[WSGI&ASGI - 简书](https://www.jianshu.com/p/65807220b44a)

### redis 缓存热点数据，哪些数据属于热点数据
  淘汰策略，不是热点的数据自动淘汰
  [redis 如何保证数据都是热点数据 - 五色风车 - 博客园](https://www.cnblogs.com/yrjns/p/12804461.html)

## 其他

- 已经有了 GIL 多线程为什么还要加锁？
- `float`相加精度问题
- 为什么协程比线程快？切换为什么快？
- `futures`模块
- 单进程里面的单进程和单进程消耗的资源哪个更多还是一样多？
- 设计模式
- redis 缓存使用？io 模型？多路复用解释一下？数据结构内部实现？
