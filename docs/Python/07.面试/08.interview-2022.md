---
title:  2022 面试记录
date: 2022-03-22 13:56:51
permalink: /interview-2022/
categories:
  - 🐍Python
  - 面试
tags:
  - 面试
---

## 捷风数据
1. (问答题)以任何语言打印一个矩阵，输入是矩阵的行数 rowNum 和矩阵的列数 colNum,这里保证输入的必然是自然数，且小于 Integer.MAX 要求在命令行打印一个如下的蛇形矩阵：
```python
   >>> 3*5
   # 输出为:
   1,6,7,12,13
   2,5,8,11,14
   3,4,9,10,15
   
   >>> 2*2
   # 输出为:
   1, 4
   2, 3
```
要求实现的人提供一个 JAR 包或者一个 python 文件, 在命令行使用
```plain
python test.py 34
   
java -jar xxxjar 3 4.
```
来打印一个 3*4 的矩阵

## 深光科技

- 索引原理，回表查询，b+树和 b 树区别？为什么不使用红黑树/二叉树，聚簇索引
- redis 使用，集群选举制度
- WSGI 实现了什么？

web 服务器在将请求转交给 web 应用程序之前，需要先将 http 报文转换为 WSGI 规定的格式。

WSGI 规定，Web 程序必须有一个可调用对象，且该可调用对象接收两个参数，返回一个可迭代对象：

`environ`：字典，包含请求的所有信息
`start_response`：在可调用对象中调用的函数，用来发起响应，参数包括状态码，headers 等

- web.py、flask、django 技术选型为什么倾向于选用 flask，（面试官倾向于选择 Django）
- 事务
- flask 运行机制
- 基类，在哪看到过？
- 脑裂是什么？
- dict 的实现

  1. [python 源码分析：dict 对象的实现 - 木易小邪 - 博客园](https://www.cnblogs.com/muyiblog/p/7662262.html)
  2. [Python dictionary implementation – Laurent Luce's Blog](http://www.laurentluce.com/posts/python-dictionary-implementation/)
- celery 实际推荐使用 rabbitMQ，为什么？

  redis 不是一个真正的消息队列，我们只是把 list 当作消息队列来使用，而 rabbitMQ 实现了消息队列中的更多功能。

## 集简慧通

- left join 与 right join

![](https://cdn.jsdelivr.net/gh/masantu/statics/images/20200427222717175.png)

left join：顾名思义，就是“左连接”，表 1 左连接表 2，以左为主，表示以表 1 为主，关联上表 2 的数据，查出来的结果显示左边的所有数据，然后右边显示的是和左边有交集部分的数据。

right join：“右连接”，表 1 右连接表 2，以右为主，表示以表 2 为主，关联查询表 1 的数据，查出表 2 所有数据以及表 1 和表 2 有交集的数据。

join：其实就是“inner join”，为了简写才写成 join，两个是表示一个的，内连接，表示以两个表的交集为主，查出来是两个表有交集的部分，其余没有关联就不额外显示出来，这个用的情况也是挺多的。

- Django 的生命周期
- 静态方法和类方法的区别
- MySQL B+树索引和哈希索引的区别
![B+树索引](https://pic1.zhimg.com/80/v2-72887788846597b4577c9ff530033694_720w.jpg?source=1940ef5c)

B+树是一个平衡的多叉树，从根节点到每个叶子节点的高度差值不超过 1，而且同层级的节点间有指针相互链接。

在 B+树上的常规检索，从根节点到叶子节点的搜索效率基本相当，不会出现大幅波动，而且基于索引的顺序扫描时，也可以利用双向指针快速左右移动，效率非常高。

![哈希索引](https://pic1.zhimg.com/80/v2-34889f812b2bb1fc1f107bebd342d50f_720w.jpg?source=1940ef5c)

哈希索引就是采用一定的哈希算法，把键值换算成新的哈希值，检索时不需要类似 B+树那样从根节点到叶子节点逐级查找，只需一次哈希算法即可立刻定位到相应的位置，速度非常快。

如果是**等值查询，那么哈希索引明显有绝对优势**，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
从示意图中也能看到，**如果是范围查询检索，哈希索引就毫无用武之地**了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
同理，哈希索引也没办法利用索引完成排序，以及 `like "xxx%"` 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
哈希索引也不支持多列联合索引的最左匹配规则；
B+树索引的关键字检索效率比较平均，不像 B 树那样波动幅度大，在有**大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题**。


- 主键索引和唯一索引的区别

主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。
主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
唯一性索引列允许空值，而主键列不允许为空值。
主键可以被其他表引用为外键，而唯一索引不能。

一个表最多只能创建一个主键，但可以创建多个唯一索引。

- `__new__` 和`__init__`区别
- Python 传值还是传引用
- Python 是否支持重载

不支持，但是也不影响。因为 Python 可以处理这种问题。
 [python-中重载](/python/interview/#python-中重载)

- 闭包
- 迭代器与生成器
- 下划线和双下划线的区别

Python 中没有真正的私有属性，但是可以用这种方式来表示私有；但是单下划线可以强制导入，而双下划线只能通过`_ClassName__var`来获取。

## 龙创悦动

- token 的工作机制
- 索引、事务/innoDB 和 MyISAM 的对比

  事务：一个最小的不可再分的工作单元
- web 框架的对比

## 大地量子

- range 返回的对象类型
  
  Python3 `range()` 函数返回的是一个可迭代对象（类型是对象），而不是列表类型， 所以打印的时候不会打印列表。

  Python3 `list()` 函数是对象迭代器，可以把`range()`返回的可迭代对象转为一个列表，返回的变量类型为列表。

  python2 中`xrange`返回生成器。

- python 版本问题
- 一行打印乘法口诀表
  
  列表生成式
- `__new__` 和`__init__`区别
- 聚集索引的概念，字段的数据类型，每页数据为什么是 16k，可以是 32k 吗？可以使用 uuid 作为聚簇索引的主键吗？
  
  增加page_size的大小：如改为32k，64k。数据库的页块大小改变需要改动源码。

- 聚索引的顺序问题
  
  聚集索引不是物理上连续的，而是逻辑上连续的。（面试官怎么问这个问题的记不住了，好像是说先插入主键为 1，3，4，之后插入 2 是否可以插入？）

- 事务四大特性，之间是否存在关联？
  
  ACID，是否存在关联不知道。。。
- innoDB 和 MyISAM 的对比
- 生成器取元素的方式，除了 next 还有哪些？
  
- 垃圾回收机制

```python
gc.get_threshold()
(700, 10, 10)
```
700 代表新创建的对象减去从新创建的对象中回收的数量的差值大于 700 就进行一次 0 代回收当 0 代回收进行 10 次的时候就进行一代回收（并且一代回收的时候也进行 0 代回收），同理，当一代回收进行 10 次的时候就进行 2  代回收（并且二代回收的时候也进行 0 代回收和一代回收）
